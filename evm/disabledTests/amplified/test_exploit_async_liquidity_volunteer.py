import brownie
import numpy as np
import pytest
from brownie import ZERO_ADDRESS, chain, convert


@pytest.fixture(autouse=True)
def isolation(module_isolation):
    pass


depositValue = 1000 * 10**18


@pytest.fixture(scope="module")
def swappool1(deploy_swappool, accounts, token1):
    yield deploy_swappool(
        [token1],
        [depositValue],
        2**60,
        "POOLNAME1",
        "PS1",
        weights=[1],
        deployer=accounts[0],
    )


@pytest.fixture(scope="module")
def swappool2(deploy_swappool, accounts, token1):
    yield deploy_swappool(
        [token1],
        [depositValue],
        2**60,
        "POOLNAME2",
        "PS2",
        weights=[1],
        deployer=accounts[0],
    )


def test_create_connections(swappool1, swappool2, accounts, chainId):
    swappool1.setConnection(
        chainId,
        convert.to_bytes(swappool2.address.replace("0x", "")),
        True,
        {"from": accounts[0]},
    )

    swappool2.setConnection(
        chainId,
        convert.to_bytes(swappool1.address.replace("0x", "")),
        True,
        {"from": accounts[0]},
    )

    swappool1.finishSetup({"from": accounts[0]})
    swappool2.finishSetup({"from": accounts[0]})


value_input = 1000 * 10**18
def test_setup(gov, accounts, token1):
    usr = accounts[2]

    token1.transfer(usr, value_input, {"from": gov})
    

def test_deposit_into_pool(accounts, swappool1, swappool2, token1):
    usr = accounts[2]

    token1.approve(swappool1, 2**256-1, {"from": usr})
    token1.approve(swappool2, 2**256-1, {"from": usr})

    depositValue = value_input * 0.5
    baseAmount = (
        int((depositValue * swappool1.totalSupply()) / token1.balanceOf(swappool1))
        - 1000
    )
    swappool1.depositMixed([depositValue], int(baseAmount*0.999), {"from": usr})

    assert int(baseAmount*0.999) <= swappool1.balanceOf(usr) <= baseAmount


def test_swap_one_direction(
    accounts, swappool1, swappool2, token1, chainId, ibcemulator
):
    usr = accounts[2]
    swapValue = token1.balanceOf(usr)  # value_input * 0.6

    tx = swappool1.sendAsset(
        chainId,
        convert.to_bytes(swappool2.address.replace("0x", "")),
        convert.to_bytes(usr.address.replace("0x", "")),
        token1,
        0,
        swapValue,
        0,
        0,  # Equal to False, False,
        usr,
        {"from": usr},
    )

    ibcemulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": usr},
    )

    ackTx = ibcemulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": usr})
    assert swappool1._escrowedTokens(token1) == 0


def test_include_liquidity_swap(
    accounts, swappool1, swappool2, chainId, ibcemulator
):
    gov = accounts[0]
    
    tx = swappool1.sendLiquidity(
        chainId,
        convert.to_bytes(swappool2.address.replace("0x", "")),
        convert.to_bytes(gov.address.replace("0x", "")),
        swappool1.balanceOf(gov)/4,
        0,
        0,
        gov,
        {"from": gov},
    )
    
    ibcemulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": gov},
    )
    

def test_exploit_state(accounts, swappool1, swappool2, token1):
    assert token1.balanceOf(swappool2) < token1.balanceOf(swappool1) / 3.5
    assert token1.balanceOf(swappool1) > value_input * 1.25
    assert swappool1.balanceOf(accounts[2]) > swappool1.totalSupply() * 0.25


def test_execute_exploit(accounts, swappool1, swappool2, token1, ibcemulator, chainId):
    usr = accounts[2]
    
    txW = swappool1.withdrawAll(swappool1.balanceOf(usr), [0, 0, 0], {"from": usr})

    tx = swappool2.sendAsset(
        chainId,
        convert.to_bytes(swappool1.address.replace("0x", "")),
        convert.to_bytes(usr.address.replace("0x", "")),
        token1,
        0,
        (token1.balanceOf(swappool1) - token1.balanceOf(swappool2))/2.031,
        0,
        0,  # Equal to False, False,
        usr,
        {"from": usr},
    )

    ibcemulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": usr},
    )

    ackTx = ibcemulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": usr})

    # assert token1.balanceOf(usr) < value_input, "The pool was exploited!"
    

def test_include_liquidity_swap_BACK(
    accounts, swappool1, swappool2, chainId, ibcemulator, token1
):
    gov = accounts[0]
    
    tx = swappool2.sendLiquidity(
        chainId,
        convert.to_bytes(swappool1.address.replace("0x", "")),
        convert.to_bytes(gov.address.replace("0x", "")),
        swappool2.balanceOf(gov) - 2**64,
        0,
        0,
        gov,
        {"from": gov},
    )
    
    ibcemulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": gov},
    )
    
    assert token1.balanceOf(accounts[2]) > value_input
    assert swappool1.balanceOf(gov) < 2**64, "Funds are lost somewhere... And a user exploited the pool."
