import pytest
from brownie import chain
from brownie.test import given, strategy
from hypothesis import example


@example(pool_percentage=7500)
@given(pool_percentage=strategy("uint256", min_value=5000, max_value=20000))
@pytest.mark.no_call_coverage
def test_large_deposit_withdrawall(pool, pool_tokens, berg, deployer, pool_percentage):
    """ 
        The purpose of this test is to check if depositing and withdrawing a significant portion of the pool doesn't impact the pool health. 
    """
    if len(pool_tokens) < 2:
        pytest.skip("Pool has to have more than 2 tokens to deposit skewed.")
    
    inital_balance0 = pool.computeBalance0()
    inital_pooltoken_value = inital_balance0 / pool.totalSupply()
    # Whatever we do in the next lines, inital_pooltoken_value shouldn't decrease.
    
    amount = pool_percentage * pool_tokens[0].balanceOf(pool) // 10000
    # Only deposit the token indexed 0.
    
    pool_tokens[0].transfer(berg, amount, {'from': deployer})
    pool_tokens[0].approve(pool, amount, {'from': berg})
    
    tx_deposit = pool.depositMixed([amount, *[0 for _ in pool_tokens[1:]]], 0, {'from': berg})
    
    # Balance0 should have increased.
    assert pool.computeBalance0() > inital_balance0
    # But the balance0 per pool token should not have decreased.
    assert pool.computeBalance0()/ pool.totalSupply() >= inital_pooltoken_value
    
    # Now withdraw even.
    tx_withdraw = pool.withdrawAll(pool.balanceOf(berg), [0, 0, 0], {'from': berg})
    
    # The balance0 per pool token should not have decreased.
    assert pool.computeBalance0() / pool.totalSupply() >= inital_pooltoken_value
    
    # Now swap
    for token in pool_tokens[1:]:
        swap_amount = token.balanceOf(berg)
        token.approve(pool, swap_amount, {'from': berg})
        
        tx = pool.localSwap(
            token, pool_tokens[0], swap_amount, 0, {'from': berg}
        )
    
    # The balance0 per pool token should not have decreased.
    assert pool.computeBalance0()/ pool.totalSupply() >= inital_pooltoken_value
    
    # Berg shouldn't have been able to withdraw anything.
    assert pool_tokens[0].balanceOf(berg) <= amount*(1+1e-10)
    
    
@example(pool_percentage=7500)
@given(pool_percentage=strategy("uint256", min_value=5000, max_value=20000))
@pytest.mark.no_call_coverage
def test_large_deposit_withdrawmixed(pool, pool_tokens, berg, deployer, pool_percentage):
    """ 
        The purpose of this test is to check if depositing and withdrawing a significant portion of the pool doesn't impact the pool health. 
    """
    if len(pool_tokens) < 2:
        pytest.skip("Pool has to have more than 2 tokens to deposit skewed.")
    
    inital_balance0 = pool.computeBalance0()
    inital_pooltoken_value = inital_balance0 / pool.totalSupply()
    # Whatever we do in the next lines, inital_pooltoken_value shouldn't decrease.
    
    amount = pool_percentage * pool_tokens[0].balanceOf(pool) // 10000
    # Only deposit the token indexed 0.
    
    pool_tokens[0].transfer(berg, amount, {'from': deployer})
    pool_tokens[0].approve(pool, amount, {'from': berg})
    
    tx_deposit = pool.depositMixed([amount, *[0 for _ in pool_tokens[1:]]], 0, {'from': berg})
    
    # Balance0 should have increased.
    assert pool.computeBalance0() > inital_balance0
    # But the balance0 per pool token should not have decreased.
    assert pool.computeBalance0()/ pool.totalSupply() >= inital_pooltoken_value
    
    # Now withdraw even.
    tx_withdraw = pool.withdrawMixed(pool.balanceOf(berg), [10**18, 0, 0], [0,0,0], {'from': berg})
    
    # The balance0 per pool token should not have decreased.
    assert pool.computeBalance0()/ pool.totalSupply() >= inital_pooltoken_value
    
    # Berg shouldn't have been able to withdraw anything.
    assert pool_tokens[0].balanceOf(berg) <= amount*(1+1e-10)