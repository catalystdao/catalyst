import pytest
from brownie import chain
from brownie.test import given, strategy
from hypothesis import example


@example(vault_percentage=7500)
@given(vault_percentage=strategy("uint256", min_value=5000, max_value=20000))
@pytest.mark.no_call_coverage
def test_large_deposit_withdrawall(vault, vault_tokens, berg, deployer, vault_percentage):
    """ 
        The purpose of this test is to check if depositing and withdrawing a significant portion of the vault doesn't impact the vault health. 
    """
    if len(vault_tokens) < 2:
        pytest.skip("Vault has to have more than 2 tokens to deposit skewed.")
    
    inital_balance0 = vault.computeBalance0()
    inital_vaulttoken_value = inital_balance0 / vault.totalSupply()
    # Whatever we do in the next lines, inital_vaulttoken_value shouldn't decrease.
    
    amount = vault_percentage * vault_tokens[0].balanceOf(vault) // 10000
    # Only deposit the token indexed 0.
    
    vault_tokens[0].transfer(berg, amount, {'from': deployer})
    vault_tokens[0].approve(vault, amount, {'from': berg})
    
    tx_deposit = vault.depositMixed([amount, *[0 for _ in vault_tokens[1:]]], 0, {'from': berg})
    
    # Balance0 should have increased.
    assert vault.computeBalance0() > inital_balance0
    # But the balance0 per vault token should not have decreased.
    assert vault.computeBalance0() / vault.totalSupply() >= inital_vaulttoken_value
    
    # Now withdraw even.
    tx_withdraw = vault.withdrawAll(vault.balanceOf(berg), [0, 0, 0], {'from': berg})
    
    # The balance0 per vault token should not have decreased.
    assert vault.computeBalance0() / vault.totalSupply() >= inital_vaulttoken_value
    
    # Now swap
    for token in vault_tokens[1:]:
        swap_amount = token.balanceOf(berg)
        token.approve(vault, swap_amount, {'from': berg})
        
        tx = vault.localSwap(
            token, vault_tokens[0], swap_amount, 0, {'from': berg}
        )
    
    # The balance0 per vault token should not have decreased.
    assert vault.computeBalance0()/ vault.totalSupply() >= inital_vaulttoken_value
    
    # Berg shouldn't have been able to withdraw anything.
    assert vault_tokens[0].balanceOf(berg) <= amount*(1+1e-10)
    
    
@example(vault_percentage=7500)
@given(vault_percentage=strategy("uint256", min_value=5000, max_value=20000))
@pytest.mark.no_call_coverage
def test_large_deposit_withdrawmixed(vault, vault_tokens, berg, deployer, vault_percentage):
    """ 
        The purpose of this test is to check if depositing and withdrawing a significant portion of the vault doesn't impact the vault health. 
    """
    if len(vault_tokens) < 2:
        pytest.skip("Vault has to have more than 2 tokens to deposit skewed.")
    
    inital_balance0 = vault.computeBalance0()
    inital_vaulttoken_value = inital_balance0 / vault.totalSupply()
    # Whatever we do in the next lines, inital_vaulttoken_value shouldn't decrease.
    
    amount = vault_percentage * vault_tokens[0].balanceOf(vault) // 10000
    # Only deposit the token indexed 0.
    
    vault_tokens[0].transfer(berg, amount, {'from': deployer})
    vault_tokens[0].approve(vault, amount, {'from': berg})
    
    tx_deposit = vault.depositMixed([amount, *[0 for _ in vault_tokens[1:]]], 0, {'from': berg})
    
    # Balance0 should have increased.
    assert vault.computeBalance0() > inital_balance0
    # But the balance0 per vault token should not have decreased.
    assert vault.computeBalance0()/ vault.totalSupply() >= inital_vaulttoken_value
    
    # Now withdraw even.
    tx_withdraw = vault.withdrawMixed(vault.balanceOf(berg), [10**18, 0, 0], [0,0,0], {'from': berg})
    
    # The balance0 per vault token should not have decreased.
    assert vault.computeBalance0()/ vault.totalSupply() >= inital_vaulttoken_value
    
    # Berg shouldn't have been able to withdraw anything.
    assert vault_tokens[0].balanceOf(berg) <= amount*(1+1e-10)