import pytest
from brownie import convert
from brownie.test import given
from hypothesis.strategies import floats
from hypothesis import example
from utils.common_utils import convert_64_bytes_address


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_vaults")


@example(swap_percentage=0.13110349782274736, deposit_percentage=0.8281814473740665)
@given(
    swap_percentage=floats(min_value=0.1, max_value=1),
    deposit_percentage=floats(min_value=0.01, max_value=1),
)
def test_execute_async_exploit(
    vault_1,
    vault_2,
    vault_1_tokens,
    vault_2_tokens,
    ibc_emulator,
    channel_id,
    elwood,
    deployer,
    swap_percentage,
    deposit_percentage,
):
    token_1 = vault_1_tokens[0]
    token_2 = vault_2_tokens[0]

    initial_balances = [
        [token.balanceOf(vault_1) for token in vault_1_tokens],
        [token.balanceOf(vault_2) for token in vault_2_tokens],
    ]

    # Approve vaults with unlimited access to elwood's funds
    token_1.approve(vault_1, 2**256 - 1, {"from": elwood})
    token_2.approve(vault_2, 2**256 - 1, {"from": elwood})

    # Swap from vault 2 to vault 1
    init_swap_amount = int(token_2.balanceOf(vault_2) * swap_percentage)

    token_2.transfer(elwood, init_swap_amount, {"from": deployer})

    tx = vault_2.sendAsset(
        channel_id,
        convert_64_bytes_address(vault_1.address),
        convert_64_bytes_address(elwood.address),
        token_2,
        0,  # Target token
        init_swap_amount,
        0,
        elwood,
        {"from": elwood},
    )

    tx_ie = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": elwood},
    )

    ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_ie.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"],
        {"from": elwood},
    )
    assert vault_2._escrowedTokens(token_2) == 0

    # Deposit on vault 1
    deposit_amount = int(token_1.balanceOf(vault_1) * deposit_percentage)

    token_1.transfer(elwood, deposit_amount, {"from": deployer})

    # vault_1_supply = vault_1.totalSupply()
    # expected_vault_tokens = int((deposit_percentage/len(vault_1_tokens)) * vault_1_supply)

    deposit_amounts = [deposit_amount] + [0] * (len(vault_1_tokens) - 1)
    vault_1.depositMixed(deposit_amounts, 0, {"from": elwood})

    # assert expected_vault_tokens*0.999 <= vault_1.balanceOf(elwood) <= expected_vault_tokens*1.001

    # Swap everything vault 1 to vault 2

    swap_amount = token_1.balanceOf(elwood)  # value_input * 0.6

    tx = vault_1.sendAsset(
        channel_id,
        convert_64_bytes_address(vault_2.address),
        convert_64_bytes_address(elwood.address),
        token_1,
        0,
        swap_amount,
        0,
        elwood,
        {"from": elwood},
    )

    tx_ie = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": elwood},
    )

    ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_ie.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"],
        {"from": elwood},
    )
    assert vault_1._escrowedTokens(token_1) == 0

    # Withdraw everything
    vault_1.withdrawMixed(
        vault_1.balanceOf(elwood),
        [10**18] + [0] * (len(vault_1_tokens) - 1),
        [0] * len(vault_1_tokens),
        {"from": elwood},
    )

    swapAmount = initial_balances[0][0] - token_1.balanceOf(vault_1)

    if swapAmount > 0:
        tx = vault_1.sendAsset(
            channel_id,
            convert_64_bytes_address(vault_2.address),
            convert_64_bytes_address(elwood.address),
            token_1,
            0,
            swapAmount,
            0,
            elwood,
            {"from": elwood},
        )

        tx_ie = ibc_emulator.execute(
            tx.events["IncomingMetadata"]["metadata"][0],
            tx.events["IncomingPacket"]["packet"],
            {"from": elwood},
        )

        ackTx = ibc_emulator.ack(
            tx.events["IncomingMetadata"]["metadata"][0],
            tx_ie.events["Acknowledgement"]["acknowledgement"],
            tx.events["IncomingPacket"]["packet"],
            {"from": elwood},
        )

    # A very very small error is allowed.
    assert (
        token_1.balanceOf(elwood) + token_2.balanceOf(elwood)
        <= int((init_swap_amount + deposit_amount) * 1.00000000000001)
    ), "The vault was exploited!"

    new_balances = [
        [token.balanceOf(vault_1) for token in vault_1_tokens],
        [token.balanceOf(vault_2) for token in vault_2_tokens],
    ]

    # Check that the vault was rebalanced at-least somewhat correctly.
    for vault1, vault2 in zip(initial_balances, new_balances):
        for balance1, balance2 in zip(vault1, vault2):
            # We allow a very very small error
            assert balance1 <= int(balance2 * 1.00000000000001)
