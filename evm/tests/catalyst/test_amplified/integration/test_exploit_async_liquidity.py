
import pytest
from brownie import convert
from brownie.test import given
from hypothesis.strategies import floats
from hypothesis import example
from utils.common_utils import convert_64_bytes_address


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")

@example(
    swap_percentage=0.13110349782274736,
    deposit_percentage=0.8281814473740665
)
@given(
    swap_percentage=floats(min_value=0.1, max_value=1),
    deposit_percentage=floats(min_value=0.01, max_value=1)
)
def test_execute_async_exploit(
    pool_1,
    pool_2,
    pool_1_tokens,
    pool_2_tokens,
    ibc_emulator,
    channel_id,
    elwood,
    deployer,
    swap_percentage,
    deposit_percentage
):
    token_1 = pool_1_tokens[0]
    token_2 = pool_2_tokens[0]
    
    initial_balances = [
        [token.balanceOf(pool_1) for token in pool_1_tokens],
        [token.balanceOf(pool_2) for token in pool_2_tokens]
    ]

    # Approve pools with unlimited access to elwood's funds
    token_1.approve(pool_1, 2**256-1, {"from": elwood})
    token_2.approve(pool_2, 2**256-1, {"from": elwood})

    # Swap from pool 2 to pool 1
    init_swap_amount = int(token_2.balanceOf(pool_2) * swap_percentage)

    token_2.transfer(elwood, init_swap_amount, {"from": deployer})

    tx = pool_2.sendAsset(
        channel_id,
        convert_64_bytes_address(pool_1.address),
        convert_64_bytes_address(elwood.address),
        token_2,
        0,          # Target token
        init_swap_amount,
        0,
        elwood,
        {"from": elwood},
    )

    tx_ie = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": elwood},
    )

    ibc_emulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx_ie.events["Acknowledgement"]["acknowledgement"], tx.events["IncomingPacket"]["packet"], {"from": elwood})
    assert pool_2._escrowedTokens(token_2) == 0
    
    # Deposit on pool 1
    deposit_amount = int(token_1.balanceOf(pool_1) * deposit_percentage)

    token_1.transfer(elwood, deposit_amount, {"from": deployer})
    
    # pool_1_supply = pool_1.totalSupply()
    # expected_pool_tokens = int((deposit_percentage/len(pool_1_tokens)) * pool_1_supply)

    deposit_amounts = [deposit_amount] + [0]*(len(pool_1_tokens)-1)
    pool_1.depositMixed(deposit_amounts, 0, {"from": elwood})

    # assert expected_pool_tokens*0.999 <= pool_1.balanceOf(elwood) <= expected_pool_tokens*1.001

    # Swap everything pool 1 to pool 2

    swap_amount = token_1.balanceOf(elwood)  # value_input * 0.6

    tx = pool_1.sendAsset(
        channel_id,
        convert_64_bytes_address(pool_2.address),
        convert_64_bytes_address(elwood.address),
        token_1,
        0,
        swap_amount,
        0,
        elwood,
        {"from": elwood},
    )

    tx_ie = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": elwood},
    )

    ibc_emulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx_ie.events["Acknowledgement"]["acknowledgement"], tx.events["IncomingPacket"]["packet"], {"from": elwood})
    assert pool_1._escrowedTokens(token_1) == 0

    # Withdraw everything
    pool_1.withdrawMixed(pool_1.balanceOf(elwood), [10**18] + [0]*(len(pool_1_tokens) - 1), [0]*len(pool_1_tokens), {"from": elwood})
    
    swapAmount = initial_balances[0][0] - token_1.balanceOf(pool_1)

    if swapAmount > 0:
        tx = pool_1.sendAsset(
            channel_id,
            convert_64_bytes_address(pool_2.address),
            convert_64_bytes_address(elwood.address),
            token_1,
            0,
            swapAmount,
            0,
            elwood,
            {"from": elwood},
        )

        tx_ie = ibc_emulator.execute(
            tx.events["IncomingMetadata"]["metadata"][0],
            tx.events["IncomingPacket"]["packet"],
            {"from": elwood},
        )

        ackTx = ibc_emulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx_ie.events["Acknowledgement"]["acknowledgement"], tx.events["IncomingPacket"]["packet"], {"from": elwood})

    assert token_1.balanceOf(elwood) + token_2.balanceOf(elwood) <= init_swap_amount + deposit_amount + 1, "The pool was exploited!"
    
    new_balances = [
        [token.balanceOf(pool_1) for token in pool_1_tokens],
        [token.balanceOf(pool_2) for token in pool_2_tokens]
    ]
    
    # Check that the pool was rebalanced at-least somewhat correctly.
    for pool1, pool2 in zip(initial_balances, new_balances):
        for balance1, balance2 in zip(pool1, pool2):
            assert balance1 <= balance2
    