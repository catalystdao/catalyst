import pytest
from brownie import  convert
from brownie.test import given
from hypothesis.strategies import floats
from hypothesis import example
from decimal import Decimal


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")

@example(
    deposit_percentage=1.274659751812416,
    arbitrage_amount_percentage=0.05647958510874497
)
@given(
    deposit_percentage=floats(min_value=0.5, max_value=2),    # From 0 to 2x the tokens hold by the pool
    arbitrage_amount_percentage=floats(min_value=0.01, max_value=0.1)  #TODO verify range
)
@pytest.mark.no_call_coverage
def test_deposit_into_pool(
    channel_id,
    pool_1,
    pool_1_tokens,
    pool_2,
    pool_2_tokens,
    get_pool_1_amp,
    ibc_emulator,
    berg,
    deployer,
    deposit_percentage,
    arbitrage_amount_percentage
):
    """ 
        This test ensures that the deposit and withdrawal methods cannot
        be exploited to return more to the user. However, it actually
        proves it can be done. But it check that the exploit returns less than 0,035% extra.
    """
    initial_pool2_balance = pool_2_tokens[0].balanceOf(pool_2)
    #TODO add test explanation

    # Deposit on pool_1
    deposit_amounts = [int(token.balanceOf(pool_1) * deposit_percentage) for token in pool_1_tokens]

    for token, amount in zip(pool_1_tokens, deposit_amounts):
        token.transfer(berg, amount, {'from': deployer})
        token.approve(pool_1, amount, {'from': berg})
    
    estimated_pool_tokens = int(pool_1.totalSupply()*deposit_percentage)
    
    pool_1.depositMixed(deposit_amounts, int(estimated_pool_tokens*0.999), {"from": berg})

    # test_arbitrage_swap_one_direction
    # Swap pool_1 to pool_2
    source_token = pool_1_tokens[0]
    target_token = pool_2_tokens[0]

    arbitrage_amount = int(arbitrage_amount_percentage * target_token.balanceOf(pool_2))

    target_token.transfer(berg, arbitrage_amount, {'from': deployer})
    target_token.approve(pool_2, arbitrage_amount, {'from': berg})

    tx = pool_2.sendAsset(
        channel_id,
        convert.to_bytes(pool_1.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        target_token,
        0,
        arbitrage_amount,
        0,
        berg,
        {"from": berg},
    )

    tx_ie = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_ie.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"], 
        {"from": berg}
    )
    assert sum([pool_1._escrowedTokens(token) for token in pool_1_tokens]) == 0

    # test_attempt_withdraw_exploit:
    
    txW = pool_1.withdrawAll(pool_1.balanceOf(berg), [0, 0, 0], {"from": berg})

    # Compute how much we need to swap back.
    a = Decimal(source_token.balanceOf(pool_1))
    b = Decimal(target_token.balanceOf(pool_2))
    y = int(arbitrage_amount)
    Wa = Decimal(pool_1._weight(source_token))
    Wb = Decimal(pool_2._weight(target_token))
    a *= Wa
    b *= Wb
    y *= Wb
    amp = Decimal(get_pool_1_amp()) / Decimal(10**18)
    oneMinusAmp = Decimal(1) - amp
    intermediate1 = b**(-amp) * y - b**oneMinusAmp
    intermediate2 = (b/(b-y))**amp
    intermediate3 = a ** oneMinusAmp + b ** oneMinusAmp
    arb_back_amount = int(((intermediate1 * intermediate2 + intermediate3)**(1/oneMinusAmp) - a)/Wa)
    
    source_token.approve(pool_1, int(arb_back_amount*1.000001), {'from': berg})
    
    tx2 = pool_1.sendAsset(
        channel_id,
        convert.to_bytes(pool_2.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        source_token,
        0,
        int(arb_back_amount*1.000001),
        0,
        berg,
        {"from": berg},
    )

    arbTx = ibc_emulator.execute(
        tx2.events["IncomingMetadata"]["metadata"][0],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(
        tx2.events["IncomingMetadata"]["metadata"][0],
        arbTx.events["Acknowledgement"]["acknowledgement"],
        tx2.events["IncomingPacket"]["packet"], 
        {"from": berg}
    )

    assert arbitrage_amount <= target_token.balanceOf(berg) <= int(arbitrage_amount*1.000003)

    print(pool_1_tokens[0].balanceOf(berg)/deposit_amounts[0])
    for token, amount in zip(pool_1_tokens, deposit_amounts):
        assert token.balanceOf(berg) <= int(amount*1.00035)
    