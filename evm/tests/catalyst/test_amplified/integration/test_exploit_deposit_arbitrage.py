import pytest
from brownie import  convert
from brownie.test import given
from hypothesis.strategies import floats
from decimal import Decimal


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")


""" @given(
    deposit_percentage=floats(min_value=0.5, max_value=2),    # From 0 to 2x the tokens hold by the pool
    arbitrage_amount_percentage=floats(min_value=0.01, max_value=0.1)  #TODO verify range
) """
@pytest.mark.no_call_coverage
def test_deposit_into_pool(
    channel_id,
    pool_1,
    pool_1_tokens,
    pool_2,
    pool_2_tokens,
    get_pool_1_amp,
    ibc_emulator,
    berg,
    deployer,
    deposit_percentage=0.5,
    arbitrage_amount_percentage=0.01
):
    initial_pool2_balance = pool_2_tokens[0].balanceOf(pool_2)
    #TODO add test explanation

    # Deposit on pool_1
    deposit_amounts = [int(token.balanceOf(pool_1) * deposit_percentage) for token in pool_1_tokens]

    for token, amount in zip(pool_1_tokens, deposit_amounts):
        token.transfer(berg, amount, {'from': deployer})
        token.approve(pool_1, amount, {'from': berg})
    
    estimated_pool_tokens = int(pool_1.totalSupply()*deposit_percentage)
    
    pool_1.depositMixed(deposit_amounts, int(estimated_pool_tokens*0.999), {"from": berg})

    # test_arbitrage_swap_one_direction
    # Swap pool_1 to pool_2
    source_token = pool_1_tokens[0]
    target_token = pool_2_tokens[0]

    arbitrage_amount = int(arbitrage_amount_percentage * target_token.balanceOf(pool_2))

    target_token.transfer(berg, arbitrage_amount, {'from': deployer})
    target_token.approve(pool_2, arbitrage_amount, {'from': berg})

    tx = pool_2.swapToUnits(
        channel_id,
        convert.to_bytes(pool_1.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        target_token,
        0,
        arbitrage_amount,
        0,
        berg,
        {"from": berg},
    )

    ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    assert sum([pool_1._escrowedTokens(token) for token in pool_1_tokens]) == 0

    # test_attempt_withdraw_exploit:
    
    txW = pool_1.withdrawAll(pool_1.balanceOf(berg), [0, 0, 0], {"from": berg})

    # Compute how much we need to swap back.
    a = Decimal(source_token.balanceOf(pool_1))
    b = Decimal(target_token.balanceOf(pool_2))
    y = pool_2_tokens[0].balanceOf(pool_2) - initial_pool2_balance
    Wa = Decimal(pool_1._weight(source_token))
    Wb = Decimal(pool_2._weight(target_token))
    a *= Wa
    b *= Wb
    amp = Decimal(get_pool_1_amp()) / Decimal(10**18)
    oneMinusAmp = Decimal(1) - amp
    intermediate1 = b**(-amp) * y - b**oneMinusAmp
    intermediate2 = (b/(b-y))**amp
    intermediate3 = a ** oneMinusAmp + b ** oneMinusAmp
    arb_back_amount = int(((intermediate1 * intermediate2 + intermediate3)**(1/oneMinusAmp) - a)/Wa)
    
    source_token.approve(pool_1, int(arb_back_amount*1.001), {'from': berg})
    
    tx2 = pool_1.swapToUnits(
        channel_id,
        convert.to_bytes(pool_2.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        source_token,
        0,
        int(arb_back_amount*1.001),
        0,
        berg,
        {"from": berg},
    )

    arbTx = ibc_emulator.execute(
        tx2.events["IncomingMetadata"]["metadata"][0],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(tx2.events["IncomingMetadata"]["metadata"][0], tx2.events["IncomingPacket"]["packet"], {"from": berg})

    assert target_token.balanceOf(berg) <= int(arbitrage_amount)
    assert target_token.balanceOf(berg) < arbitrage_amount 

    for token, amount in zip(pool_1_tokens, deposit_amounts):
        assert token.balanceOf(berg) <= amount
    