import pytest
from brownie import convert
from brownie.test import given
from hypothesis.strategies import floats
from hypothesis import example
from decimal import Decimal
from utils.common_utils import convert_64_bytes_address


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_vaults")


@example(
    deposit_percentage=1.274659751812416,
    arbitrage_amount_percentage=0.05647958510874497,
)
@given(
    deposit_percentage=floats(
        min_value=0.5, max_value=2
    ),  # From 0 to 2x the tokens hold by the vault
    arbitrage_amount_percentage=floats(
        min_value=0.01, max_value=0.1
    ),  # TODO verify range
)
@pytest.mark.no_call_coverage
def test_deposit_into_vault(
    channel_id,
    vault_1,
    vault_1_tokens,
    vault_2,
    vault_2_tokens,
    get_vault_1_amp,
    ibc_emulator,
    berg,
    deployer,
    deposit_percentage,
    arbitrage_amount_percentage,
):
    """
    This test ensures that the deposit and withdrawal methods cannot
    be exploited to return more to the user. However, it actually
    proves it can be done. But it check that the exploit returns less than 0,035% extra.
    """
    initial_vault2_balance = vault_2_tokens[0].balanceOf(vault_2)
    # TODO add test explanation

    # Deposit on vault_1
    deposit_amounts = [
        int(token.balanceOf(vault_1) * deposit_percentage) for token in vault_1_tokens
    ]

    for token, amount in zip(vault_1_tokens, deposit_amounts):
        token.transfer(berg, amount, {"from": deployer})
        token.approve(vault_1, amount, {"from": berg})

    estimated_vault_tokens = int(vault_1.totalSupply() * deposit_percentage)

    vault_1.depositMixed(
        deposit_amounts, int(estimated_vault_tokens * 0.999), {"from": berg}
    )

    # test_arbitrage_swap_one_direction
    # Swap vault_1 to vault_2
    source_token = vault_1_tokens[0]
    target_token = vault_2_tokens[0]

    arbitrage_amount = int(
        arbitrage_amount_percentage * target_token.balanceOf(vault_2)
    )

    target_token.transfer(berg, arbitrage_amount, {"from": deployer})
    target_token.approve(vault_2, arbitrage_amount, {"from": berg})

    tx = vault_2.sendAsset(
        channel_id,
        convert_64_bytes_address(vault_1.address),
        convert_64_bytes_address(berg.address),
        target_token,
        0,
        arbitrage_amount,
        0,
        berg,
        {"from": berg},
    )

    tx_ie = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_ie.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )
    assert sum([vault_1._escrowedTokens(token) for token in vault_1_tokens]) == 0

    # test_attempt_withdraw_exploit:

    txW = vault_1.withdrawAll(vault_1.balanceOf(berg), [0, 0, 0], {"from": berg})

    # Compute how much we need to swap back.
    a = Decimal(source_token.balanceOf(vault_1))
    b = Decimal(target_token.balanceOf(vault_2))
    y = int(arbitrage_amount)
    Wa = Decimal(vault_1._weight(source_token))
    Wb = Decimal(vault_2._weight(target_token))
    a *= Wa
    b *= Wb
    y *= Wb
    amp = Decimal(get_vault_1_amp()) / Decimal(10**18)
    oneMinusAmp = Decimal(1) - amp
    intermediate1 = b ** (-amp) * y - b**oneMinusAmp
    intermediate2 = (b / (b - y)) ** amp
    intermediate3 = a**oneMinusAmp + b**oneMinusAmp
    arb_back_amount = int(
        ((intermediate1 * intermediate2 + intermediate3) ** (1 / oneMinusAmp) - a) / Wa
    )

    source_token.approve(vault_1, int(arb_back_amount * 1.000001), {"from": berg})

    tx2 = vault_1.sendAsset(
        channel_id,
        convert_64_bytes_address(vault_2.address),
        convert_64_bytes_address(berg.address),
        source_token,
        0,
        int(arb_back_amount * 1.000001),
        0,
        berg,
        {"from": berg},
    )

    arbTx = ibc_emulator.execute(
        tx2.events["IncomingMetadata"]["metadata"][0],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(
        tx2.events["IncomingMetadata"]["metadata"][0],
        arbTx.events["Acknowledgement"]["acknowledgement"],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    assert (
        arbitrage_amount
        <= target_token.balanceOf(berg)
        <= int(arbitrage_amount * 1.000003)
    )

    print(vault_1_tokens[0].balanceOf(berg) / deposit_amounts[0])
    for token, amount in zip(vault_1_tokens, deposit_amounts):
        assert token.balanceOf(berg) <= int(amount * 1.00035)
