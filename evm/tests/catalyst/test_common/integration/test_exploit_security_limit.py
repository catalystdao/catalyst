import pytest
from brownie import convert, reverts, chain
from brownie.exceptions import VirtualMachineError
from decimal import Decimal
from utils.common_utils import convert_64_bytes_address

from tests.catalyst.utils.pool_utils import encode_swap_payload


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")

@pytest.mark.no_call_coverage
def test_exploit_security_limit_with_timeout(
    channel_id,
    pool_1,
    pool_2,
    pool_1_tokens,
    get_pool_1_amp,
    ibc_emulator,
    cross_chain_interface,
    deployer,
    elwood
):
    """
        * This test sometimes fail. Please rerun if that is the case *
        From the bridge/router perspective: attempt to bypass the security limit by using a timed-out swap:
            1. Extract from the pool as many assets as possible (security limit will allow 1/2 the pool value)
            2. Using those assets, trigger an outgoing swap from the pool that is being attacked to some other pool. In
               general terms, this will cause the unit capacity of the pool to increase.
                => The bridge will have the power to timeout the swap and recover the assets sent
            3. Try to extract more
                => If the unit capacity increase gets updated BEFORE a swap ack is received this exploit will succeed
                => Otherwise, the bridge will be unable of extracting any more assets
    """

    # First, extract half of pool 1 (reach security limit)
    # NOTE: do so across all the tokens contained by the pool, otherwise, for amplified pools,
    # the pool may run out of assets before the security limit is reached
    
    # Extract approximately the same value of each asset. The unit_capacity left is computed on each loop, 
    # as for amplified pools it is dependent on the asset balances (and here assets are being withdrawn on each iteration)
    # For a pool with 3 assets, this loop will extract 1) U = unit_capacity * 1/3, 2) unit_capacity * 1/2, 3) unit_capacity * 1/1
    for i, token in enumerate(pool_1_tokens):
        # The 'elwood' account will be the one trying to steal the funds
        assert token.balanceOf(elwood) == 0

        chain.mine()    # Make sure the unit_capacity reading is as accurate as possible (as it is time dependent)
        unit_capacity = pool_1.getUnitCapacity()
        
        # For amplified pools, we need to convert the unit_capacity to true units.
        if get_pool_1_amp() != 10**18:
            amp = get_pool_1_amp()
            amp /= 10**18
            # We want use some portion of the capacity to purchase tokens.
            y = (int(unit_capacity * 1/(len(pool_1_tokens)-i)))
            
            balance = token.balanceOf(pool_1)
            balance *= pool_1._weight(token)
            
            unit_capacity = int((balance**(1-amp) - (balance - y)**(1-amp))) * 10**18
        else:
            unit_capacity = int(unit_capacity * 1/(len(pool_1_tokens)-i)) - 1

        fake_payload = encode_swap_payload(
            pool_2.address,     # Fake swap coming from pool 2 (doe't really matter, it only must be a 'connected' pool)
            pool_1.address,
            elwood.address,
            unit_capacity,
            i,
        )
        fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]     #TODO add helper to build packet
        tx = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})
        

    # At this point 'elwood' has extracted 1/2 of the pool.
    # NOTE: the stolen funds amount don't necessarily equal the funds left in the pool, as there can be more than
    # one token hold by the pool, and the tokens are not retrieved symmetrically.

    assert pool_1.getUnitCapacity() <= int(0.00001 * pool_1._maxUnitCapacity())   # Check the unit capacity is 0 (allow for a small error due to calculation errors)

    # From this point onwards, use only one token to continue with the extraction of funds from the pool. There is no further
    # risk of emptying an amplified pool of assets (as no more assets should be allowed to be stolen). In any case,
    # if the amplified pool were to be emptied (e.g. by the following swap), the test would fail and hence become invalid.

    target_token_index = 0
    target_token = pool_1_tokens[target_token_index]
    inital_stolen_funds_balance = target_token.balanceOf(elwood)

    # Try to extract more (should fail, as the limit has been reached)
    try:
        amount_to_try = int(0.001 * 10e18)
        if get_pool_1_amp() != 10**18:
            B = Decimal(target_token.balanceOf(pool_1)) * pool_1._weight(target_token)
            y = Decimal(pool_1.getUnitCapacity() * pool_1._weight(target_token))
            amp = Decimal(get_pool_1_amp())/Decimal(10**18)
            amount_to_try = int((B**(-amp) * y - B**(1-amp))*((B-y)/B)**(-amp) + B**(1-amp))
        
        fake_payload = encode_swap_payload(
            pool_2.address,
            pool_1.address,
            elwood.address,
            amount_to_try,    # Even a very small value of units should fail
            target_token_index,
        )
        fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]
        
        unit_capacity_before = pool_1.getUnitCapacity()

        tx = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})
        
        # Transaction might silently fail (with ack).
        if "ReceiveAsset" in tx.events.keys():
            assert tx.events["ReceiveAsset"]["toAmount"] <= unit_capacity_before, "Security limit has been circumvented"
    except VirtualMachineError:
        # Desired. Continue with the test.
        pass

    # Send a cross chain swap with the stolen funds to increase the pool unit capacity (knowing that it will fail)
    target_token.approve(pool_1, inital_stolen_funds_balance, {"from": elwood})
    tx_send_asset = pool_1.sendAsset(
        channel_id,
        convert_64_bytes_address(pool_2.address),   # NOTE: target pool doesn't matter
        convert_64_bytes_address(deployer.address),
        target_token,
        0,                                  # NOTE: target asset index doesn't matter
        inital_stolen_funds_balance,
        0,
        elwood,
        {"from": elwood},
    )

    # Extract more
    max_units = pool_1.getUnitCapacity()

    fake_payload = encode_swap_payload(
        pool_2.address,
        pool_1.address,
        elwood.address,
        max_units,
        0,
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]
    cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})


    # Time out the swap to recover the initially stolen assets
    ibc_emulator.timeout(
        tx_send_asset.events["IncomingMetadata"]["metadata"][0],
        tx_send_asset.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )

    # If the balance of 'elwood' exceeds the initial stolen balance it means the security limit was exploited.
    # NOTE: Allow for a small extra margin due to the security limit decay
    assert target_token.balanceOf(elwood) < int(1.01 * inital_stolen_funds_balance), "Pool was exploited"
