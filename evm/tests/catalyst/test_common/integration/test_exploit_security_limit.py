import pytest
from brownie import convert, reverts, chain
from brownie.exceptions import VirtualMachineError
from decimal import Decimal
from utils.common_utils import convert_64_bytes_address

from tests.catalyst.utils.vault_utils import encode_swap_payload


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_vaults")


@pytest.mark.no_call_coverage
def test_exploit_security_limit_with_timeout(
    channel_id,
    vault_1,
    vault_2,
    vault_1_tokens,
    get_vault_1_amp,
    ibc_emulator,
    cross_chain_interface,
    deployer,
    elwood,
):
    """
    * This test sometimes fail. Please rerun if that is the case *
    From the bridge/router perspective: attempt to bypass the security limit by using a timed-out swap:
        1. Extract from the vault as many assets as possible (security limit will allow 1/2 the vault value)
        2. Using those assets, trigger an outgoing swap from the vault that is being attacked to some other vault. In
           general terms, this will cause the unit capacity of the vault to increase.
            => The bridge will have the power to timeout the swap and recover the assets sent
        3. Try to extract more
            => If the unit capacity increase gets updated BEFORE a swap ack is received this exploit will succeed
            => Otherwise, the bridge will be unable of extracting any more assets
    """

    # First, extract half of vault 1 (reach security limit)
    # NOTE: do so across all the tokens contained by the vault, otherwise, for amplified vaults,
    # the vault may run out of assets before the security limit is reached

    # Extract approximately the same value of each asset. The unit_capacity left is computed on each loop,
    # as for amplified vaults it is dependent on the asset balances (and here assets are being withdrawn on each iteration)
    # For a vault with 3 assets, this loop will extract 1) U = unit_capacity * 1/3, 2) unit_capacity * 1/2, 3) unit_capacity * 1/1
    for i, token in enumerate(vault_1_tokens):
        # The 'elwood' account will be the one trying to steal the funds
        assert token.balanceOf(elwood) == 0

        chain.mine()  # Make sure the unit_capacity reading is as accurate as possible (as it is time dependent)
        unit_capacity = vault_1.getUnitCapacity()

        # For amplified vaults, we need to convert the unit_capacity to true units.
        if get_vault_1_amp() != 10**18:
            amp = get_vault_1_amp()
            amp /= 10**18
            # We want use some portion of the capacity to purchase tokens.
            y = int(unit_capacity * 1 / (len(vault_1_tokens) - i))

            balance = token.balanceOf(vault_1)
            balance *= vault_1._weight(token)

            unit_capacity = (
                int(balance ** (1 - amp) - (balance - y) ** (1 - amp)) * 10**18
            )
        else:
            unit_capacity = int(unit_capacity * 1 / (len(vault_1_tokens) - i)) - 1

        fake_payload = encode_swap_payload(
            vault_2.address,  # Fake swap coming from vault 2 (doe't really matter, it only must be a 'connected' vault)
            vault_1.address,
            elwood.address,
            unit_capacity,
            i,
        )
        fake_packet = [
            ["", channel_id],
            ["", ""],
            0,
            fake_payload,
            [0, 0],
        ]  # TODO add helper to build packet
        tx = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # At this point 'elwood' has extracted 1/2 of the vault.
    # NOTE: the stolen funds amount don't necessarily equal the funds left in the vault, as there can be more than
    # one token hold by the vault, and the tokens are not retrieved symmetrically.

    assert vault_1.getUnitCapacity() <= int(
        0.000001 * vault_1._maxUnitCapacity()
    )  # Check the unit capacity is 0 (allow for a small error due to calculation errors)

    # From this point onwards, use only one token to continue with the extraction of funds from the vault. There is no further
    # risk of emptying an amplified vault of assets (as no more assets should be allowed to be stolen). In any case,
    # if the amplified vault were to be emptied (e.g. by the following swap), the test would fail and hence become invalid.

    target_token_index = 0
    target_token = vault_1_tokens[target_token_index]
    inital_stolen_funds_balance = target_token.balanceOf(elwood)

    # Try to extract more (should fail, as the limit has been reached)
    try:
        amount_to_try = int(0.001 * 10e18)
        if get_vault_1_amp() != 10**18:
            B = Decimal(target_token.balanceOf(vault_1)) * vault_1._weight(target_token)
            y = Decimal(vault_1.getUnitCapacity() * vault_1._weight(target_token))
            amp = Decimal(get_vault_1_amp()) / Decimal(10**18)
            amount_to_try = int(
                (B ** (-amp) * y - B ** (1 - amp)) * ((B - y) / B) ** (-amp)
                + B ** (1 - amp)
            )

        fake_payload = encode_swap_payload(
            vault_2.address,
            vault_1.address,
            elwood.address,
            amount_to_try,  # Even a very small value of units should fail
            target_token_index,
        )
        fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

        unit_capacity_before = vault_1.getUnitCapacity()

        tx = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

        # Transaction might silently fail (with ack).
        if "ReceiveAsset" in tx.events.keys():
            assert (
                tx.events["ReceiveAsset"]["toAmount"] <= unit_capacity_before
            ), "Security limit has been circumvented"
    except VirtualMachineError:
        # Desired. Continue with the test.
        pass

    # Send a cross chain swap with the stolen funds to increase the vault unit capacity (knowing that it will fail)
    target_token.approve(vault_1, inital_stolen_funds_balance, {"from": elwood})
    tx_send_asset = vault_1.sendAsset(
        channel_id,
        convert_64_bytes_address(vault_2.address),  # NOTE: target vault doesn't matter
        convert_64_bytes_address(deployer.address),
        target_token,
        0,  # NOTE: target asset index doesn't matter
        inital_stolen_funds_balance,
        0,
        elwood,
        {"from": elwood},
    )

    # Extract more
    max_units = vault_1.getUnitCapacity()

    fake_payload = encode_swap_payload(
        vault_2.address,
        vault_1.address,
        elwood.address,
        max_units,
        0,
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]
    cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # Time out the swap to recover the initially stolen assets
    ibc_emulator.timeout(
        tx_send_asset.events["IncomingMetadata"]["metadata"][0],
        tx_send_asset.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )

    # If the balance of 'elwood' exceeds the initial stolen balance it means the security limit was exploited.
    # NOTE: Allow for a small extra margin due to the security limit decay
    assert target_token.balanceOf(elwood) < int(
        1.01 * inital_stolen_funds_balance
    ), "Vault was exploited"
