import pytest
from brownie import convert, reverts, chain
from utils.common_utils import convert_64_bytes_address

pytestmark = pytest.mark.usefixtures("vault_finish_setup", "vault_connect_itself")


@pytest.mark.no_call_coverage
def test_local_swap_with_worthless_token(
    vault, vault_tokens, create_token, elwood, swap_vault_type
):

    source_token = create_token("", "", 18, 10000, elwood)  # Create a worthless token
    target_token = vault_tokens[0]

    # Send some of the worthless token to the vault to make sure that any calculations that takes
    # into account the current vault balance of the token doesn't fail
    source_token.transfer(vault, 10**18, {"from": elwood})

    assert target_token.balanceOf(elwood) == 0

    swap_amount = 10**18
    source_token.approve(vault, swap_amount, {"from": elwood})

    if swap_vault_type == "volatile":
        vault.localSwap(source_token, target_token, swap_amount, 0, {"from": elwood})

        assert target_token.balanceOf(elwood) == 0

    else:
        # For amplified vaults the swap reverts as the swap calculation tries to compute the power of 0.
        # This is not supported by the mathematical library
        with reverts():
            vault.localSwap(
                source_token, target_token, swap_amount, 0, {"from": elwood}
            )


@pytest.mark.no_call_coverage
def test_cross_swap_with_worthless_token(
    vault, channel_id, create_token, elwood, swap_vault_type
):

    # Create a worthless token
    source_token = create_token("", "", 18, 10000, elwood)

    # Send some of the worthless token to the vault to make sure that any calculations that takes
    # into account the current vault balance of the token doesn't fail
    source_token.transfer(vault, 10**18, {"from": elwood})

    swap_amount = 10**18
    source_token.approve(vault, swap_amount, {"from": elwood})

    if swap_vault_type == "volatile":
        tx = vault.sendAsset(
            channel_id,
            convert_64_bytes_address(
                vault.address
            ),  # NOTE: target vault doesn't matter
            convert_64_bytes_address(elwood.address),
            source_token,
            0,  # NOTE: target asset index doesn't matter
            swap_amount,
            0,
            elwood,
            {"from": elwood},
        )

        assert tx.events["SendAsset"]["units"] == 0
    else:
        # For amplified vaults the swap reverts as the swap calculation tries to compute the power of 0.
        # This is not supported by the mathematical library
        with reverts():
            tx = vault.sendAsset(
                channel_id,
                convert_64_bytes_address(
                    vault.address
                ),  # NOTE: target vault doesn't matter
                convert_64_bytes_address(elwood.address),
                source_token,
                0,  # NOTE: target asset index doesn't matter
                swap_amount,
                0,
                elwood,
                {"from": elwood},
            )
