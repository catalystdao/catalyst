import pytest
from brownie import convert, reverts, chain
from utils.common_utils import convert_64_bytes_address

pytestmark = pytest.mark.usefixtures("pool_connect_itself", "pool_finish_setup", )

@pytest.mark.no_call_coverage
def test_local_swap_with_worthless_token(
    pool,
    pool_tokens,
    create_token,
    elwood,
    swap_pool_type
):

    source_token = create_token("", "", 18, 10000, elwood)  # Create a worthless token
    target_token = pool_tokens[0]

    # Send some of the worthless token to the pool to make sure that any calculations that takes
    # into account the current pool balance of the token doesn't fail 
    source_token.transfer(pool, 10**18, {"from": elwood})

    assert target_token.balanceOf(elwood) == 0

    swap_amount = 10**18
    source_token.approve(pool, swap_amount, {"from": elwood})

    if swap_pool_type == "volatile":
        pool.localSwap(
            source_token,
            target_token,
            swap_amount,
            0,
            {"from": elwood}
        )

        assert target_token.balanceOf(elwood) == 0
    
    else:
        # For amplified pools the swap reverts as the swap calculation tries to compute the power of 0.
        # This is not supported by the mathematical library
        with reverts():
            pool.localSwap(
                source_token,
                target_token,
                swap_amount,
                0,
                {"from": elwood}
            )



@pytest.mark.no_call_coverage
def test_cross_swap_with_worthless_token(
    pool,
    channel_id,
    create_token,
    elwood,
    swap_pool_type
):

    # Create a worthless token
    source_token = create_token("", "", 18, 10000, elwood)

    # Send some of the worthless token to the pool to make sure that any calculations that takes
    # into account the current pool balance of the token doesn't fail 
    source_token.transfer(pool, 10**18, {"from": elwood})

    swap_amount = 10**18
    source_token.approve(pool, swap_amount, {"from": elwood})

    if swap_pool_type == "volatile":
        tx = pool.sendAsset(
            channel_id,
            convert_64_bytes_address(pool.address),   # NOTE: target pool doesn't matter
            convert_64_bytes_address(elwood.address),
            source_token,
            0,                                  # NOTE: target asset index doesn't matter
            swap_amount,
            0,
            elwood,
            {"from": elwood},
        )

        assert tx.events['SendAsset']['units'] == 0
    else:
        # For amplified pools the swap reverts as the swap calculation tries to compute the power of 0.
        # This is not supported by the mathematical library
        with reverts():
            tx = pool.sendAsset(
                channel_id,
                convert_64_bytes_address(pool.address),   # NOTE: target pool doesn't matter
                convert_64_bytes_address(elwood.address),
                source_token,
                0,                                  # NOTE: target asset index doesn't matter
                swap_amount,
                0,
                elwood,
                {"from": elwood},
            )
