import pytest
from brownie import ZERO_ADDRESS, chain, convert
from brownie.test import given, strategy


pytestmark = pytest.mark.usefixtures("connect_pools", "finish_setup")
    

@pytest.mark.no_call_coverage
@given(percentage=strategy("uint256", max_value=20000), arb_amount=strategy("uint256", max_value=10*10**6))
def test_deposit_into_pool(accounts, channelId, swappool1, swappool2, ibcemulator, get_pool_tokens, berg, deployer, percentage, arb_amount):
    percentage /= 10000
    
    tokens1 = get_pool_tokens(swappool1)
    tokens2 = get_pool_tokens(swappool2)
    amounts = [int(token.balanceOf(swappool1) * percentage) for token in tokens1]
    [token.transfer(berg, amount, {'from': deployer}) for token, amount in zip(tokens1, amounts)]
    [token.approve(swappool1, amount, {'from': berg}) for token, amount in zip(tokens1, amounts)]
    
    estimatedPoolTokens = int(swappool1.totalSupply()*percentage)
    
    swappool1.depositMixed(amounts, int(estimatedPoolTokens*0.999), {"from": berg})

    # test_arbitrage_swap_one_direction
    
    tokens2[0].transfer(berg, arb_amount, {'from': deployer})
    tokens2[0].approve(swappool2, arb_amount, {'from': berg})

    tx = swappool2.swapToUnits(
        channelId,
        convert.to_bytes(swappool1.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        tokens2[0],
        0,
        arb_amount,
        0,
        berg,
        {"from": berg},
    )

    ibcemulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibcemulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    assert sum([swappool1._escrowedTokens(token) for token in tokens1]) == 0

    # test_attempt_withdraw_exploit:
    
    txW = swappool1.withdrawAll(swappool1.balanceOf(berg), [0, 0, 0], {"from": berg})

    # Compute how much we need to swap back.
    y = arb_amount
    a = tokens1[0].balanceOf(swappool1)
    b = tokens2[0].balanceOf(swappool2)
    Wa = swappool1._weight(tokens1[0])
    Wb = swappool2._weight(tokens2[0])
    arb_back_amount = a*(((b - y)/b)**(-Wb/Wa) - 1)
    
    tokens1[0].approve(swappool1, int(arb_back_amount*1.001), {'from': berg})
    
    tx2 = swappool1.swapToUnits(
        channelId,
        convert.to_bytes(swappool2.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        tokens1[0],
        0,
        int(arb_back_amount*1.001),
        0,
        berg,
        {"from": berg},
    )

    ibcemulator.execute(
        tx2.events["IncomingMetadata"]["metadata"][0],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibcemulator.ack(tx2.events["IncomingMetadata"]["metadata"][0], tx2.events["IncomingPacket"]["packet"], {"from": berg})

    assert arb_amount <= tokens2[0].balanceOf(berg) <= int(arb_amount*1.001)

    for token, amount in zip(tokens1, amounts):
        assert token.balanceOf(berg) <= amount
    