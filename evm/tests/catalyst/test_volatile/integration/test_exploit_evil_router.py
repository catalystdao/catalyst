import math
import pytest
from brownie import convert, reverts, chain

from tests.catalyst.utils.vault_utils import (
    encode_swap_payload,
    encode_liquidity_swap_payload,
)


pytestmark = pytest.mark.usefixtures("vault_finish_setup", "vault_connect_itself")


@pytest.mark.no_call_coverage
def test_extract_value_via_asset_swap(
    channel_id, vault, vault_tokens, ibc_emulator, cross_chain_interface, elwood
):
    """
    Verify that a malicious bridge/router can extract the maximum allowed by the security limit
    from a vault by faking an asset swap.
    """

    target_token_index = 0
    target_token = vault_tokens[target_token_index]

    assert target_token.balanceOf(elwood) == 0

    initial_target_token_balance = target_token.balanceOf(vault)

    # Extract the maximum allowed capacity
    units = vault.getUnitCapacity()

    fake_payload = encode_swap_payload(
        vault.address, vault.address, elwood.address, units, target_token_index
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

    cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # Extracting 1/2 the vault value with a single token from the vault means leaving (1/2)**N of the
    # asset on the vault, where N is the number of assets in the vault.
    # The extracted ratio of the token is 1/2 for a vault with 1 token, 3/4 for 2 tokens, 7/8 for 3 tokens ...
    extraction_ratio = 1 - 1 / (2 ** len(vault_tokens))
    expected_extraction = initial_target_token_balance * extraction_ratio
    assert (
        expected_extraction * 1.01
        > target_token.balanceOf(elwood)
        > expected_extraction * 0.99
    )


@pytest.mark.no_call_coverage
def test_extract_value_via_asset_swap_too_greedy(
    channel_id, vault, vault_tokens, ibc_emulator, cross_chain_interface, elwood
):
    """
    Verify that a malicious bridge/router cannot extract more than the maximum allowed by the security limit
    from a vault by faking an asset swap.
    """

    target_token_index = 0
    target_token = vault_tokens[target_token_index]

    assert target_token.balanceOf(elwood) == 0

    # Try to extract more than the maximum allowed capacity
    units = int(vault.getUnitCapacity() * 1.0001)

    fake_payload = encode_swap_payload(
        vault.address,
        vault.address,
        elwood.address,
        units,
        target_token_index,
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

    # with reverts():
    txe = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})
    # Ensure no tokens are transfered.
    assert "Transfer" not in txe.events.keys()

    assert target_token.balanceOf(elwood) == 0


@pytest.mark.no_call_coverage
def test_extract_value_via_liquidity_swap(
    channel_id, vault, vault_tokens, ibc_emulator, cross_chain_interface, elwood
):
    """
    Verify that a malicious bridge/router can extract the maximum allowed by the security limit
    from a vault by faking a liquidity swap.
    """

    initial_supply = vault.totalSupply()

    # Extract the maximum allowed capacity
    units = vault.getUnitCapacity()

    fake_payload = encode_liquidity_swap_payload(
        vault.address,
        vault.address,
        elwood.address,
        units,
        [1, 0],
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

    cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # If half of the vault value is received, then as many vault tokens as the current totalSupply should be minted
    # (hence, 'elwood' would effectively have half of the new current supply of vault tokens)
    assert 1 * 1.01 > vault.balanceOf(elwood) / initial_supply > 1 * 0.99
    assert 1 / 2 * 1.01 > vault.balanceOf(elwood) / vault.totalSupply() > 1 / 2 * 0.99

    # Withdraw the vault tokens
    vault.withdrawAll(
        vault.balanceOf(elwood), [0] * len(vault_tokens), {"from": elwood}
    )

    assert vault.totalSupply() == initial_supply

    for token in vault_tokens:
        assert 1 * 1.01 > token.balanceOf(elwood) / token.balanceOf(vault) > 1 * 0.99


def test_extract_value_via_liquidity_swap_too_greedy(
    channel_id, vault, ibc_emulator, cross_chain_interface, elwood
):
    """
    Verify that a malicious bridge/router cannot extract more than the maximum allowed by the security limit
    from a vault by faking a liquidity swap.
    """

    # Try to extract more than the maximum allowed capacity
    units = int(vault.getUnitCapacity() * 1.0001)

    fake_payload = encode_liquidity_swap_payload(
        vault.address,
        vault.address,
        elwood.address,
        units,
        [1, 0],
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

    # with reverts():
    txe = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # Ensure no tokens are transfered.
    assert "Transfer" not in txe.events.keys()
