import math
import pytest
from brownie import convert, reverts, chain

from tests.catalyst.utils.pool_utils import encode_swap_payload, encode_liquidity_swap_payload


pytestmark = pytest.mark.usefixtures("pool_finish_setup", "pool_connect_itself")

@pytest.mark.no_call_coverage
def test_extract_value_via_asset_swap(
    channel_id,
    pool,
    pool_tokens,
    ibc_emulator,
    cross_chain_interface,
    elwood
):
    """
        Verify that a malicious bridge/router can extract the maximum allowed by the security limit
        from a pool by faking an asset swap.
    """

    target_token_index = 0
    target_token = pool_tokens[target_token_index]

    assert target_token.balanceOf(elwood) == 0

    initial_target_token_balance = target_token.balanceOf(pool)

    # Extract the maximum allowed capacity
    units = pool.getUnitCapacity()

    fake_payload = encode_swap_payload(
        pool.address,
        pool.address,
        convert.to_bytes(elwood.address),
        units,
        target_token_index
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

    cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # Extracting 1/2 the pool value with a single token from the pool means leaving (1/2)**N of the 
    # asset on the pool, where N is the number of assets in the pool.
    # The extracted ratio of the token is 1/2 for a pool with 1 token, 3/4 for 2 tokens, 7/8 for 3 tokens ...
    extraction_ratio = 1 - 1/(2**len(pool_tokens))
    expected_extraction = initial_target_token_balance * extraction_ratio
    assert expected_extraction * 1.01 > target_token.balanceOf(elwood) > expected_extraction * 0.99


@pytest.mark.no_call_coverage
def test_extract_value_via_asset_swap_too_greedy(
    channel_id,
    pool,
    pool_tokens,
    ibc_emulator,
    cross_chain_interface,
    elwood
):
    """
        Verify that a malicious bridge/router cannot extract more than the maximum allowed by the security limit
        from a pool by faking an asset swap.
    """

    target_token_index = 0
    target_token = pool_tokens[target_token_index]

    assert target_token.balanceOf(elwood) == 0

    # Try to extract more than the maximum allowed capacity
    units = int(pool.getUnitCapacity() * 1.0001)

    fake_payload = encode_swap_payload(
        pool.address,
        pool.address,
        convert.to_bytes(elwood.address),
        units,
        target_token_index,
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

    # with reverts():
    txe = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})
    # Ensure no tokens are transfered.
    assert "Transfer" not in txe.events.keys()

    assert target_token.balanceOf(elwood) == 0


@pytest.mark.no_call_coverage
def test_extract_value_via_liquidity_swap(
    channel_id,
    pool,
    pool_tokens,
    ibc_emulator,
    cross_chain_interface,
    elwood
):
    """
        Verify that a malicious bridge/router can extract the maximum allowed by the security limit
        from a pool by faking a liquidity swap.
    """

    initial_supply = pool.totalSupply()

    # Extract the maximum allowed capacity
    units = pool.getUnitCapacity()

    fake_payload = encode_liquidity_swap_payload(
        pool.address,
        pool.address,
        convert.to_bytes(elwood.address),
        units,
        [1, 0],
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

    cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # If half of the pool value is received, then as many pool tokens as the current totalSupply should be minted
    # (hence, 'elwood' would effectively have half of the new current supply of pool tokens)
    assert 1 * 1.01 > pool.balanceOf(elwood) / initial_supply > 1 * 0.99
    assert 1/2 * 1.01 > pool.balanceOf(elwood) / pool.totalSupply() > 1/2 * 0.99

    # Withdraw the pool tokens
    pool.withdrawAll(pool.balanceOf(elwood), [0]*len(pool_tokens), {"from": elwood})

    assert pool.totalSupply() == initial_supply

    for token in pool_tokens:
        assert 1 * 1.01 > token.balanceOf(elwood) / token.balanceOf(pool) > 1 * 0.99


def test_extract_value_via_liquidity_swap_too_greedy(
    channel_id,
    pool,
    ibc_emulator,
    cross_chain_interface,
    elwood
):
    """
        Verify that a malicious bridge/router cannot extract more than the maximum allowed by the security limit
        from a pool by faking a liquidity swap.
    """

    # Try to extract more than the maximum allowed capacity
    units = int(pool.getUnitCapacity() * 1.0001)

    fake_payload = encode_liquidity_swap_payload(
        pool.address,
        pool.address,
        convert.to_bytes(elwood.address),
        units,
        [1, 0],
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

    # with reverts():
    txe = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})
    
    # Ensure no tokens are transfered.
    assert "Transfer" not in txe.events.keys()
