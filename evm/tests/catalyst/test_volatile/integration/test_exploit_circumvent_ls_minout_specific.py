import pytest
from brownie import convert, reverts, chain
from brownie.exceptions import VirtualMachineError
from decimal import Decimal
from math import log, exp

from tests.catalyst.utils.pool_utils import encode_swap_payload


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")


@pytest.fixture(scope="module")
def pool_1_s_tokens(create_token):
    tokens = []
    tokens.append(create_token("A", "A", 18, 10000))
    tokens.append(create_token("B", "B", 18, 10000))
    tokens.append(create_token("C", "C", 18, 10000))
    yield tokens

@pytest.fixture(scope="module")
def pool_1_s(pool_1_s_tokens, deploy_pool):
    pool1 = deploy_pool(
        pool_1_s_tokens,
        [1000*10**18, 1000*10**18, 1000*10**18],
        [1,1,1],
        10**18,
        "Pool 1",
        "P1"
    )
    
    yield pool1

@pytest.fixture(scope="module")
def pool_2_s(pool_1_s_tokens, deploy_pool):
    pool2 = deploy_pool(
        pool_1_s_tokens,
        [1000*10**18, 1000*10**18, 1000*10**18],
        [1,1,1],
        10**18,
        "Pool 2",
        "P2"
    )
    
    yield pool2


@pytest.mark.no_call_coverage
def test_circumvent_minout_is_fixed(
    channel_id,
    pool_1_s,
    pool_2_s,
    pool_1_s_tokens,
    ibc_emulator,
    deployer,
    berg,
    elwood
):
    pool_1 = pool_1_s
    pool_2 = pool_2_s
    pool_1.setConnection(channel_id, convert.to_bytes(pool_2.address.replace("0x", "")), True, {'from': deployer})
    pool_2.setConnection(channel_id, convert.to_bytes(pool_1.address.replace("0x", "")), True, {'from': deployer})
    pool_1_tokens = pool_1_s_tokens
    bob = berg
    alice = elwood
    
    for token in pool_1_tokens:
        token.transfer(bob, 250*10**18, {'from': deployer})
        token.transfer(alice, 500*10**18, {'from': deployer})
        token.approve(pool_1, 2**256-1, {'from': bob})
        token.approve(pool_1, 2**256-1, {'from': alice})
        token.approve(pool_2, 2**256-1, {'from': bob})
        token.approve(pool_2, 2**256-1, {'from': alice})
        
    
    """ Bob deposits 250 of each asset into pool 1. """
    
    pool_1.depositMixed([250*10**18, 250*10**18, 250*10**18], 0, {'from': bob})
    
    """ Alice notices this is about to happen and deposits [250, 250, 250] just before the swap. """
    
    pool_1.depositMixed([250*10**18, 250*10**18, 250*10**18], 0, {'from': alice})
    
    for token in pool_1_tokens:
        assert token.balanceOf(pool_1) == 1500*10**18
    
    """ However, Bob anticipated this situation and set the minOut parameter. """
    
    tx = pool_1.sendLiquidity(
        channel_id,
        convert.to_bytes(pool_2.address.replace("0x", "")),
        convert.to_bytes(bob.address.replace("0x", "")),
        int(125*10**18/1000),
        [111*10**18, 0],
        bob,
        {"from": bob},
    )
    
    with reverts():
        # Execute the transaction.
        tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    
    chain.undo(3)  # Undo the failed tx_execute, send liquidity and deposited mixed of alice.
    
    tx = pool_1.sendLiquidity(
        channel_id,
        convert.to_bytes(pool_2.address.replace("0x", "")),
        convert.to_bytes(bob.address.replace("0x", "")),
        int(125*10**18/1000),
        [111*10**18/1000, 0],
        bob,
        {"from": bob},
    )
    
    tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    bob, 
    assert pool_2.balanceOf(bob) > 111*10**18/1000
    chain.undo(2)  # Undo the above test.
    
    """ Alice notices this is about to happen and deposits [250, 250, 250] just before the swap. continued...."""
    
    pool_1.depositMixed([250*10**18, 250*10**18, 250*10**18], 0, {'from': alice})
    
    """ To thwart the set minOut, Alice now deposits [222.3, 222.3, 222.3] into P2, receiving 222.3 pool tokens in P2. """
    
    pool_2.depositMixed([222.3*10**18, 222.3*10**18, 222.3*10**18], 0, {'from': alice})
    
    """ Now Bob’s sendLiquidity request is received. He receives 125/(1500-124)*1222.3 = 111.111… pool tokens in P2, as desired.  """
    
    tx = pool_1.sendLiquidity(
        channel_id,
        convert.to_bytes(pool_2.address.replace("0x", "")),
        convert.to_bytes(bob.address.replace("0x", "")),
        int(125*10**18/1000),
        [111*10**18/1000, 0],
        bob,
        {"from": bob},
    )
    
    tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    assert pool_2.balanceOf(bob) > 111*10**18/1000
    
    ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )
    
    pool_1.withdrawAll(pool_1.balanceOf(alice), [0,0,0], {'from': alice})
    pool_2.withdrawAll(pool_2.balanceOf(alice), [0,0,0], {'from': alice})
    
    for token in pool_1_tokens:
        assert token.balanceOf(alice) > 500*10**18
    
    """ The exploit works. Lets now defeat it by using the reference balance """
    chain.undo(7)
    
    # Check we that we undid both deposits.
    assert pool_1.balanceOf(alice) == 0
    assert pool_2.balanceOf(alice) == 0
    
    pt_out = 111*10**18/1000
    asset_reference_amount = exp(
        sum(
            [log(token.balanceOf(pool_2))*pool_2._weight(token) for token in pool_1_tokens]
        )/sum([pool_2._weight(token) for token in pool_1_tokens])
        )
    min_asset_reference_amount = int((asset_reference_amount * pt_out) / (pool_2.totalSupply() + pt_out))
    
    assert min_asset_reference_amount == 99909990999099752448
    
    """ Test that the swap still exeutes. """
    
    tx = pool_1.sendLiquidity(
        channel_id,
        convert.to_bytes(pool_2.address.replace("0x", "")),
        convert.to_bytes(bob.address.replace("0x", "")),
        int(125*10**18/1000),
        [111*10**18/1000, min_asset_reference_amount],
        bob,
        {"from": bob},
    )
    
    tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    assert pool_2.balanceOf(bob) > 111*10**18/1000
    
    ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )
    
    tx_a = pool_2.withdrawAll(pool_2.balanceOf(berg), [0,0,0], {'from': berg})
    
    chain.undo(1)
    
    chain.undo(3)
    
    """ Alice notices this is about to happen and deposits [250, 250, 250] just before the swap. continued...."""
    
    pool_1.depositMixed([250*10**18, 250*10**18, 250*10**18], 0, {'from': alice})
    
    """ To thwart the set minOut, Alice now deposits [222.3, 222.3, 222.3] into P2, receiving 222.3 pool tokens in P2. """
    
    pool_2.depositMixed([222.3*10**18, 222.3*10**18, 222.3*10**18], 0, {'from': alice})
    
    """ Test that the swap executes, but that Alice cannot withdraw more than she put in. """
    
    tx = pool_1.sendLiquidity(
        channel_id,
        convert.to_bytes(pool_2.address.replace("0x", "")),
        convert.to_bytes(bob.address.replace("0x", "")),
        int(125*10**18/1000),
        [111*10**18/1000, min_asset_reference_amount],
        bob,
        {"from": bob},
    )
    
    tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    
    ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )
    
    """ Test that alice cannot withdraw more than set put in. """
    
    pool_1.withdrawAll(pool_1.balanceOf(alice), [0,0,0], {'from': alice})
    pool_2.withdrawAll(pool_2.balanceOf(alice), [0,0,0], {'from': alice})
    
    # Test that Bob still gets the same amount of tokens out as without Alice's interactions.
    
    tx_b = pool_2.withdrawAll(pool_2.balanceOf(bob), [0,0,0], {'from': bob})
    
    for amount_without, amount_with in zip(tx_a.events["Withdraw"]["assets"], tx_b.events["Withdraw"]["assets"]):
        assert amount_without < amount_with
    
    """ Check no value has left the pool """
    
    for i, token in zip(range(len(pool_1_tokens)), pool_1_tokens):
        swap_amount = 1000*10**18 - token.balanceOf(pool_2)
        tx = pool_2.sendAsset(
            channel_id,
            convert.to_bytes(pool_1.address.replace("0x", "")),
            convert.to_bytes(berg.address.replace("0x", "")),
            token,
            i,
            swap_amount,
            0,
            bob,
            {"from": bob},
        )
        
        tx_execute = ibc_emulator.execute(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
        
        ibc_emulator.ack(
            tx.events["IncomingMetadata"]["metadata"][0],
            tx.events["IncomingPacket"]["packet"],
            {"from": deployer},
        )
    
    
    tx_b = pool_1.withdrawAll(pool_1.balanceOf(bob), [0,0,0], {'from': bob})
    
    
    # Same number of pool tokens
    assert pool_1.totalSupply() == 10**18
    assert pool_2.totalSupply() == 10**18
    
    # More (or equal) tokens within the pools.
    for token in pool_1_tokens:
        assert 1000*10**18 <= token.balanceOf(pool_1)
        assert 1000*10**18 <= token.balanceOf(pool_2)
    