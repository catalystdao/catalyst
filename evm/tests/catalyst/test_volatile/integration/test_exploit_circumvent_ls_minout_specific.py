import pytest
from brownie import convert, reverts, chain
from brownie.exceptions import VirtualMachineError
from decimal import Decimal
from math import log, exp
from utils.common_utils import convert_64_bytes_address

from tests.catalyst.utils.vault_utils import encode_swap_payload


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_vaults")


@pytest.fixture(scope="module")
def vault_1_s_tokens(create_token):
    tokens = []
    tokens.append(create_token("A", "A", 18, 10000))
    tokens.append(create_token("B", "B", 18, 10000))
    tokens.append(create_token("C", "C", 18, 10000))
    yield tokens


@pytest.fixture(scope="module")
def vault_1_s(vault_1_s_tokens, deploy_vault):
    vault1 = deploy_vault(
        vault_1_s_tokens,
        [1000 * 10**18, 1000 * 10**18, 1000 * 10**18],
        [1, 1, 1],
        10**18,
        "Vault 1",
        "P1",
    )

    yield vault1


@pytest.fixture(scope="module")
def vault_2_s(vault_1_s_tokens, deploy_vault):
    vault2 = deploy_vault(
        vault_1_s_tokens,
        [1000 * 10**18, 1000 * 10**18, 1000 * 10**18],
        [1, 1, 1],
        10**18,
        "Vault 2",
        "P2",
    )

    yield vault2


@pytest.mark.no_call_coverage
def test_circumvent_minout_is_fixed(
    channel_id,
    vault_1_s,
    vault_2_s,
    vault_1_s_tokens,
    ibc_emulator,
    deployer,
    berg,
    elwood,
):
    vault_1 = vault_1_s
    vault_2 = vault_2_s
    vault_1.setConnection(
        channel_id,
        convert.to_bytes(20, "bytes1")
        + convert.to_bytes(0)
        + convert.to_bytes(vault_2.address.replace("0x", "")),
        True,
        {"from": deployer},
    )
    vault_2.setConnection(
        channel_id,
        convert.to_bytes(20, "bytes1")
        + convert.to_bytes(0)
        + convert.to_bytes(vault_1.address.replace("0x", "")),
        True,
        {"from": deployer},
    )
    vault_1_tokens = vault_1_s_tokens
    bob = berg
    alice = elwood

    for token in vault_1_tokens:
        token.transfer(bob, 250 * 10**18, {"from": deployer})
        token.transfer(alice, 500 * 10**18, {"from": deployer})
        token.approve(vault_1, 2**256 - 1, {"from": bob})
        token.approve(vault_1, 2**256 - 1, {"from": alice})
        token.approve(vault_2, 2**256 - 1, {"from": bob})
        token.approve(vault_2, 2**256 - 1, {"from": alice})

    """ Bob deposits 250 of each asset into vault 1. """

    vault_1.depositMixed(
        [250 * 10**18, 250 * 10**18, 250 * 10**18], 0, {"from": bob}
    )

    """ Alice notices this is about to happen and deposits [250, 250, 250] just before the swap. """

    vault_1.depositMixed(
        [250 * 10**18, 250 * 10**18, 250 * 10**18], 0, {"from": alice}
    )

    for token in vault_1_tokens:
        assert token.balanceOf(vault_1) == 1500 * 10**18

    """ However, Bob anticipated this situation and set the minOut parameter. """

    tx = vault_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(vault_2.address),
        convert_64_bytes_address(bob.address),
        int(125 * 10**18 / 1000),
        [111 * 10**18, 0],
        bob,
        {"from": bob},
    )

    # Execute the transaction. (It will ack on fail:)
    tx_execute = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    assert tx_execute.events["Acknowledgement"]["acknowledgement"] == hex(1)

    chain.undo(
        3
    )  # Undo the failed tx_execute, send liquidity and deposited mixed of alice.

    tx = vault_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(vault_2.address),
        convert_64_bytes_address(bob.address),
        int(125 * 10**18 / 1000),
        [111 * 10**18 / 1000, 0],
        bob,
        {"from": bob},
    )

    tx_execute = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )
    bob,
    assert vault_2.balanceOf(bob) > 111 * 10**18 / 1000
    chain.undo(2)  # Undo the above test.

    """ Alice notices this is about to happen and deposits [250, 250, 250] just before the swap. continued...."""

    vault_1.depositMixed(
        [250 * 10**18, 250 * 10**18, 250 * 10**18], 0, {"from": alice}
    )

    """ To thwart the set minOut, Alice now deposits [222.3, 222.3, 222.3] into P2, receiving 222.3 vault tokens in P2. """

    vault_2.depositMixed(
        [222.3 * 10**18, 222.3 * 10**18, 222.3 * 10**18], 0, {"from": alice}
    )

    """ Now Bob’s sendLiquidity request is received. He receives 125/(1500-124)*1222.3 = 111.111… vault tokens in P2, as desired.  """

    tx = vault_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(vault_2.address),
        convert_64_bytes_address(bob.address),
        int(125 * 10**18 / 1000),
        [111 * 10**18 / 1000, 0],
        bob,
        {"from": bob},
    )

    tx_execute = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )
    assert vault_2.balanceOf(bob) > 111 * 10**18 / 1000

    ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_execute.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )

    vault_1.withdrawAll(vault_1.balanceOf(alice), [0, 0, 0], {"from": alice})
    vault_2.withdrawAll(vault_2.balanceOf(alice), [0, 0, 0], {"from": alice})

    for token in vault_1_tokens:
        assert token.balanceOf(alice) > 500 * 10**18

    """ The exploit works. Lets now defeat it by using the reference balance """
    chain.undo(7)

    # Check we that we undid both deposits.
    assert vault_1.balanceOf(alice) == 0
    assert vault_2.balanceOf(alice) == 0

    pt_out = 111 * 10**18 / 1000
    asset_reference_amount = exp(
        sum(
            [
                log(token.balanceOf(vault_2)) * vault_2._weight(token)
                for token in vault_1_tokens
            ]
        )
        / sum([vault_2._weight(token) for token in vault_1_tokens])
    )
    min_asset_reference_amount = int(
        (asset_reference_amount * pt_out) / (vault_2.totalSupply() + pt_out)
    )

    assert min_asset_reference_amount == 99909990999099752448

    """ Test that the swap still exeutes. """

    tx = vault_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(vault_2.address),
        convert_64_bytes_address(bob.address),
        int(125 * 10**18 / 1000),
        [111 * 10**18 / 1000, min_asset_reference_amount],
        bob,
        {"from": bob},
    )

    tx_execute = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )
    assert vault_2.balanceOf(bob) > 111 * 10**18 / 1000

    ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_execute.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )

    tx_a = vault_2.withdrawAll(vault_2.balanceOf(berg), [0, 0, 0], {"from": berg})

    chain.undo(1)

    chain.undo(3)

    """ Alice notices this is about to happen and deposits [250, 250, 250] just before the swap. continued...."""

    vault_1.depositMixed(
        [250 * 10**18, 250 * 10**18, 250 * 10**18], 0, {"from": alice}
    )

    """ To thwart the set minOut, Alice now deposits [222.3, 222.3, 222.3] into P2, receiving 222.3 vault tokens in P2. """

    vault_2.depositMixed(
        [222.3 * 10**18, 222.3 * 10**18, 222.3 * 10**18], 0, {"from": alice}
    )

    """ Test that the swap executes, but that Alice cannot withdraw more than she put in. """

    tx = vault_1.sendLiquidity(
        channel_id,
        convert_64_bytes_address(vault_2.address),
        convert_64_bytes_address(bob.address),
        int(125 * 10**18 / 1000),
        [111 * 10**18 / 1000, min_asset_reference_amount],
        bob,
        {"from": bob},
    )

    tx_execute = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_execute.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )

    """ Test that alice cannot withdraw more than set put in. """

    vault_1.withdrawAll(vault_1.balanceOf(alice), [0, 0, 0], {"from": alice})
    vault_2.withdrawAll(vault_2.balanceOf(alice), [0, 0, 0], {"from": alice})

    # Test that Bob still gets the same amount of tokens out as without Alice's interactions.

    tx_b = vault_2.withdrawAll(vault_2.balanceOf(bob), [0, 0, 0], {"from": bob})

    for amount_without, amount_with in zip(
        tx_a.events["Withdraw"]["assets"], tx_b.events["Withdraw"]["assets"]
    ):
        assert amount_without < amount_with

    """ Check no value has left the vault """

    for i, token in zip(range(len(vault_1_tokens)), vault_1_tokens):
        swap_amount = 1000 * 10**18 - token.balanceOf(vault_2)
        tx = vault_2.sendAsset(
            channel_id,
            convert_64_bytes_address(vault_1.address),
            convert_64_bytes_address(berg.address),
            token,
            i,
            swap_amount,
            0,
            bob,
            {"from": bob},
        )

        tx_execute = ibc_emulator.execute(
            tx.events["IncomingMetadata"]["metadata"][0],
            tx.events["IncomingPacket"]["packet"],
            {"from": berg},
        )

        ibc_emulator.ack(
            tx.events["IncomingMetadata"]["metadata"][0],
            tx_execute.events["Acknowledgement"]["acknowledgement"],
            tx.events["IncomingPacket"]["packet"],
            {"from": deployer},
        )

    tx_b = vault_1.withdrawAll(vault_1.balanceOf(bob), [0, 0, 0], {"from": bob})

    # Same number of vault tokens
    assert vault_1.totalSupply() == 10**18
    assert vault_2.totalSupply() == 10**18

    # More (or equal) tokens within the vaults.
    for token in vault_1_tokens:
        assert 1000 * 10**18 <= token.balanceOf(vault_1)
        assert 1000 * 10**18 <= token.balanceOf(vault_2)
