import pytest
from brownie import convert
from brownie.test import given
from hypothesis.strategies import floats
from utils.common_utils import convert_64_bytes_address


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_vaults")


@pytest.mark.no_call_coverage
@given(
    deposit_percentage=floats(
        min_value=0, max_value=2
    ),  # From 0 to 2x the tokens hold by the vault
    arbitrage_amount_percentage=floats(min_value=0, max_value=0.1),  # TODO verify range
)
def test_deposit_into_vault(
    channel_id,
    vault_1,
    vault_1_tokens,
    vault_2,
    vault_2_tokens,
    ibc_emulator,
    berg,
    deployer,
    deposit_percentage,
    arbitrage_amount_percentage,
):
    # TODO add test explanation

    # Deposit on vault_1
    deposit_amounts = [
        int(token.balanceOf(vault_1) * deposit_percentage) for token in vault_1_tokens
    ]

    for token, amount in zip(vault_1_tokens, deposit_amounts):
        token.transfer(berg, amount, {"from": deployer})
        token.approve(vault_1, amount, {"from": berg})

    estimated_vault_tokens = int(vault_1.totalSupply() * deposit_percentage)

    vault_1.depositMixed(
        deposit_amounts, int(estimated_vault_tokens * 0.999), {"from": berg}
    )

    # test_arbitrage_swap_one_direction
    # Swap vault_1 to vault_2
    source_token = vault_1_tokens[0]
    target_token = vault_2_tokens[0]

    arbitrage_amount = int(
        arbitrage_amount_percentage * target_token.balanceOf(vault_2)
    )

    target_token.transfer(berg, arbitrage_amount, {"from": deployer})
    target_token.approve(vault_2, arbitrage_amount, {"from": berg})

    tx = vault_2.sendAsset(
        channel_id,
        convert_64_bytes_address(vault_1.address),
        convert_64_bytes_address(berg.address),
        target_token,
        0,
        arbitrage_amount,
        0,
        berg,
        {"from": berg},
    )

    tx_execute = ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx_execute.events["Acknowledgement"]["acknowledgement"],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )
    assert sum([vault_1._escrowedTokens(token) for token in vault_1_tokens]) == 0

    # test_attempt_withdraw_exploit:

    txW = vault_1.withdrawAll(vault_1.balanceOf(berg), [0, 0, 0], {"from": berg})

    # Compute how much we need to swap back.
    y = arbitrage_amount
    a = source_token.balanceOf(vault_1)
    b = target_token.balanceOf(vault_2)
    Wa = vault_1._weight(source_token)
    Wb = vault_2._weight(target_token)
    arb_back_amount = a * (((b - y) / b) ** (-Wb / Wa) - 1)

    source_token.approve(vault_1, int(arb_back_amount * 1.001), {"from": berg})

    tx2 = vault_1.sendAsset(
        channel_id,
        convert_64_bytes_address(vault_2.address),
        convert_64_bytes_address(berg.address),
        source_token,
        0,
        int(arb_back_amount * 1.001),
        0,
        berg,
        {"from": berg},
    )

    tx_execute = ibc_emulator.execute(
        tx2.events["IncomingMetadata"]["metadata"][0],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(
        tx2.events["IncomingMetadata"]["metadata"][0],
        tx_execute.events["Acknowledgement"]["acknowledgement"],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    assert (
        arbitrage_amount
        <= target_token.balanceOf(berg)
        <= int(arbitrage_amount * 1.001)
    )

    for token, amount in zip(vault_1_tokens, deposit_amounts):
        assert token.balanceOf(berg) <= amount
