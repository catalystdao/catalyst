import pytest
from brownie import  convert
from brownie.test import given
from hypothesis.strategies import floats


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")


@pytest.mark.no_call_coverage
@given(
    deposit_percentage=floats(min_value=0, max_value=2),    # From 0 to 2x the tokens hold by the pool
    arbitrage_amount_percentage=floats(min_value=0, max_value=0.1)  #TODO verify range
)
def test_deposit_into_pool(
    channel_id,
    pool_1,
    pool_1_tokens,
    pool_2,
    pool_2_tokens,
    ibc_emulator,
    berg,
    deployer,
    deposit_percentage,
    arbitrage_amount_percentage
):
    #TODO add test explanation

    # Deposit on pool_1
    deposit_amounts = [int(token.balanceOf(pool_1) * deposit_percentage) for token in pool_1_tokens]

    for token, amount in zip(pool_1_tokens, deposit_amounts):
        token.transfer(berg, amount, {'from': deployer})
        token.approve(pool_1, amount, {'from': berg})
    
    estimated_pool_tokens = int(pool_1.totalSupply()*deposit_percentage)
    
    pool_1.depositMixed(deposit_amounts, int(estimated_pool_tokens*0.999), {"from": berg})


    # test_arbitrage_swap_one_direction
    # Swap pool_1 to pool_2
    source_token = pool_1_tokens[0]
    target_token = pool_2_tokens[0]

    arbitrage_amount = int(arbitrage_amount_percentage * target_token.balanceOf(pool_2))

    target_token.transfer(berg, arbitrage_amount, {'from': deployer})
    target_token.approve(pool_2, arbitrage_amount, {'from': berg})

    tx = pool_2.sendAsset(
        channel_id,
        convert.to_bytes(pool_1.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        target_token,
        0,
        arbitrage_amount,
        0,
        berg,
        {"from": berg},
    )

    ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    assert sum([pool_1._escrowedTokens(token) for token in pool_1_tokens]) == 0

    # test_attempt_withdraw_exploit:
    
    txW = pool_1.withdrawAll(pool_1.balanceOf(berg), [0, 0, 0], {"from": berg})


    # Compute how much we need to swap back.
    y = arbitrage_amount
    a = source_token.balanceOf(pool_1)
    b = target_token.balanceOf(pool_2)
    Wa = pool_1._weight(source_token)
    Wb = pool_2._weight(target_token)
    arb_back_amount = a*(((b - y)/b)**(-Wb/Wa) - 1)
    
    source_token.approve(pool_1, int(arb_back_amount*1.001), {'from': berg})
    
    tx2 = pool_1.sendAsset(
        channel_id,
        convert.to_bytes(pool_2.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        source_token,
        0,
        int(arb_back_amount*1.001),
        0,
        berg,
        {"from": berg},
    )

    ibc_emulator.execute(
        tx2.events["IncomingMetadata"]["metadata"][0],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(tx2.events["IncomingMetadata"]["metadata"][0], tx2.events["IncomingPacket"]["packet"], {"from": berg})

    assert arbitrage_amount <= target_token.balanceOf(berg) <= int(arbitrage_amount*1.001)

    for token, amount in zip(pool_1_tokens, deposit_amounts):
        assert token.balanceOf(berg) <= amount
    