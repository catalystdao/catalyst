import brownie
import numpy as np
import pytest
from brownie import ZERO_ADDRESS, chain, convert


@pytest.fixture(autouse=True)
def isolation(module_isolation):
    pass


depositValue = 1000 * 10**18


@pytest.fixture(scope="module")
def swappool1(deploy_swappool, accounts, token1):
    yield deploy_swappool(
        [token1],
        [depositValue],
        2**59,
        "POOLNAME1",
        "PS1",
        weights=[1],
        deployer=accounts[0],
    )


@pytest.fixture(scope="module")
def swappool2(deploy_swappool, accounts, token1):
    yield deploy_swappool(
        [token1],
        [depositValue],
        2**59,
        "POOLNAME2",
        "PS2",
        weights=[1],
        deployer=accounts[0],
    )


def test_create_connections(swappool1, swappool2, accounts, chainId):
    swappool1.createConnection(
        chainId,
        convert.to_bytes(swappool2.address.replace("0x", "")),
        True,
        {"from": accounts[0]},
    )

    swappool2.createConnection(
        chainId,
        convert.to_bytes(swappool1.address.replace("0x", "")),
        True,
        {"from": accounts[0]},
    )

    swappool1.finishSetup({"from": accounts[0]})
    swappool2.finishSetup({"from": accounts[0]})


value_input = 1000 * 10**18
def test_setup(gov, accounts, token1, swappool1, swappool2):
    usr = accounts[2]

    token1.transfer(usr, value_input, {"from": gov})
    token1.approve(swappool1, 2**256-1, {"from": usr})
    token1.approve(swappool2, 2**256-1, {"from": usr})
    
    
def test_swap_before(
    accounts, swappool1, swappool2, token1, chainId, ibcemulator
):
    usr = accounts[2]
    swapValue = token1.balanceOf(usr) / 4  # value_input * 0.6

    tx = swappool2.swapToUnits(
        chainId,
        convert.to_bytes(swappool1.address.replace("0x", "")),
        convert.to_bytes(usr.address.replace("0x", "")),
        token1,
        0,
        swapValue,
        0,
        0,  # Equal to False, False,
        usr,
        {"from": usr},
    )

    ibcemulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": usr},
    )

    ackTx = ibcemulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": usr})
    assert swappool2._escrowedTokens(token1) == 0


def test_deposit_into_pool(accounts, swappool1, swappool2, token1):
    usr = accounts[2]

    depositValue = value_input * 0.7  # We leave 50% to swap, since that lets to max out the security limit. And we assume that someone can arbitrage the pool before the security limit is reset.
    baseAmount = (
        int((depositValue * swappool1.totalSupply()) / token1.balanceOf(swappool1))
        - 1000
    )
    swappool1.depositMixed([depositValue], baseAmount-1, {"from": balance_modifier})

    assert swappool1.balanceOf(usr) == baseAmount


def test_swap_one_direction(
    accounts, swappool1, swappool2, token1, chainId, ibcemulator
):
    usr = accounts[2]
    swapValue = token1.balanceOf(usr)  # value_input * 0.6

    tx = swappool1.swapToUnits(
        chainId,
        convert.to_bytes(swappool2.address.replace("0x", "")),
        convert.to_bytes(usr.address.replace("0x", "")),
        token1,
        0,
        swapValue,
        0,
        0,  # Equal to False, False,
        usr,
        {"from": usr},
    )

    ibcemulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": usr},
    )

    ackTx = ibcemulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": usr})
    assert swappool1._escrowedTokens(token1) == 0


def test_execute_exploit(accounts, swappool1, swappool2, token1, ibcemulator, chainId):
    usr = accounts[2]
    
    txW = swappool1.withdrawAll(swappool1.balanceOf(usr), [0, 0, 0], {"from": usr})

    swapAmount = (token1.balanceOf(swappool1) - token1.balanceOf(swappool2))/2

    if swapAmount > 0:
        tx = swappool2.swapToUnits(
            chainId,
            convert.to_bytes(swappool1.address.replace("0x", "")),
            convert.to_bytes(usr.address.replace("0x", "")),
            token1,
            0,
            swapAmount,
            0,
            0,  # Equal to False, False,
            usr,
            {"from": usr},
        )
    else: 
        tx = swappool1.swapToUnits(
            chainId,
            convert.to_bytes(swappool2.address.replace("0x", "")),
            convert.to_bytes(usr.address.replace("0x", "")),
            token1,
            0,
            -swapAmount,
            0,
            0,  # Equal to False, False,
            usr,
            {"from": usr},
        )

    ibcemulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": usr},
    )

    ackTx = ibcemulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": usr})

    assert token1.balanceOf(usr) < value_input, "The pool was exploited!"
    